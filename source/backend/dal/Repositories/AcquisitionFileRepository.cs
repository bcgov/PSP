using System;
using System.Collections.Generic;
using System.Linq;
using System.Security.Claims;
using LinqKit;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using Pims.Core.Exceptions;
using Pims.Core.Extensions;
using Pims.Dal.Entities;
using Pims.Dal.Entities.Models;
using Pims.Dal.Helpers.Extensions;

namespace Pims.Dal.Repositories
{
    /// <summary>
    /// Provides a repository to interact with acquisition files within the datasource.
    /// </summary>
    public class AcquisitionFileRepository : BaseRepository<PimsAcquisitionFile>, IAcquisitionFileRepository
    {
        private readonly ISequenceRepository _sequenceRepository;
        #region Constructors

        /// <summary>
        /// Creates a new instance of a AcquisitionFileRepository, and initializes it with the specified arguments.
        /// </summary>
        /// <param name="dbContext"></param>
        /// <param name="user"></param>
        /// <param name="logger"></param>
        public AcquisitionFileRepository(PimsContext dbContext, ClaimsPrincipal user, ILogger<AcquisitionFileRepository> logger, ISequenceRepository sequenceRepository)
            : base(dbContext, user, logger)
        {
            _sequenceRepository = sequenceRepository;
        }
        #endregion

        #region Methods

        /// <summary>
        /// Retrieves a page with an array of acquisition files within the specified filters.
        /// Note that the 'filter' will control the 'page' and 'quantity'.
        /// </summary>
        /// <param name="filter"></param>
        /// <param name="regions"></param>
        /// <returns></returns>
        public Paged<PimsAcquisitionFile> GetPageDeep(AcquisitionFilter filter, HashSet<short> regions, long? contractorPersonId = null)
        {
            // RECOMMENDED - use a log scope to group all potential SQL statements generated by EF for this method call
            using var scope = Logger.QueryScope();

            filter.ThrowIfNull(nameof(filter));
            if (!filter.IsValid())
            {
                throw new ArgumentException("Argument must have a valid filter", nameof(filter));
            }

            IQueryable<PimsAcquisitionFile> query = GetCommonAcquisitionFileQueryDeep(filter, regions, contractorPersonId);

            var skip = (filter.Page - 1) * filter.Quantity;
            var pageItems = query.Skip(skip).Take(filter.Quantity).ToList();

            return new Paged<PimsAcquisitionFile>(pageItems, filter.Page, filter.Quantity, query.Count());
        }

        /// <summary>
        /// Get Acquisition Files for Export.
        /// </summary>
        /// <param name="filter"></param>
        /// <param name="regions"></param>
        /// <param name="contractorPersonId"></param>
        /// <returns></returns>
        public List<PimsAcquisitionFile> GetAcquisitionFileExportDeep(AcquisitionFilter filter, HashSet<short> regions, long? contractorPersonId = null)
        {
            // RECOMMENDED - use a log scope to group all potential SQL statements generated by EF for this method call
            using var scope = Logger.QueryScope();

            filter.ThrowIfNull(nameof(filter));
            if (!filter.IsValid())
            {
                throw new ArgumentException("Argument must have a valid filter", nameof(filter));
            }

            return GetCommonAcquisitionFileQueryDeep(filter, regions, contractorPersonId).ToList();
        }

        /// <summary>
        /// Retrieves the acquisition file with the specified id.
        /// </summary>
        /// <param name="id"></param>
        /// <returns></returns>
        public PimsAcquisitionFile GetById(long id)
        {
            using var scope = Logger.QueryScope();

            return Context.PimsAcquisitionFiles.AsNoTracking()
                .Include(r => r.AcquisitionFileStatusTypeCodeNavigation)
                .Include(r => r.AcqPhysFileStatusTypeCodeNavigation)
                .Include(r => r.AcquisitionTypeCodeNavigation)
                .Include(r => r.RegionCodeNavigation)
                .Include(r => r.AcquisitionFundingTypeCodeNavigation)
                .Include(r => r.SubfileInterestTypeCodeNavigation)
                .Include(s => s.PimsAcqFileAcqProgresses)
                    .ThenInclude(p => p.AcqFileProgessTypeCodeNavigation)
                .Include(s => s.AcqFileAppraisalTypeCodeNavigation)
                .Include(s => s.AcqFileLglSrvyTypeCodeNavigation)
                .Include(s => s.PimsAcqFileAcqFlTakeTyps)
                    .ThenInclude(t => t.AcqFileTakeTypeCodeNavigation)
                .Include(s => s.AcqFileExpropRiskTypeCodeNavigation)
                .Include(r => r.Project)
                    .ThenInclude(x => x.WorkActivityCode)
                .Include(r => r.Project)
                    .ThenInclude(x => x.CostTypeCode)
                .Include(r => r.Project)
                    .ThenInclude(x => x.BusinessFunctionCode)
                .Include(r => r.Project)
                    .ThenInclude(x => x.PimsProjectPeople)
                .Include(r => r.Product)
                .Include(r => r.PimsPropertyAcquisitionFiles)
                .Include(r => r.PimsAcquisitionFileTeams)
                    .ThenInclude(rp => rp.Person)
                .Include(r => r.PimsAcquisitionFileTeams)
                    .ThenInclude(rp => rp.Organization)
                .Include(r => r.PimsAcquisitionFileTeams)
                    .ThenInclude(rp => rp.PrimaryContact)
                .Include(r => r.PimsAcquisitionFileTeams)
                    .ThenInclude(rp => rp.AcqFlTeamProfileTypeCodeNavigation)
                .Include(r => r.PimsAcquisitionOwners)
                    .ThenInclude(x => x.Address)
                        .ThenInclude(x => x.ProvinceState)
                .Include(r => r.PimsAcquisitionOwners)
                    .ThenInclude(x => x.Address)
                        .ThenInclude(x => x.Country)
                .Include(r => r.PimsInterestHolders)
                    .ThenInclude(rp => rp.InterestHolderTypeCodeNavigation)
                .Include(r => r.PimsInterestHolders)
                    .ThenInclude(rp => rp.Person)
                .Include(r => r.PimsInterestHolders)
                    .ThenInclude(rp => rp.Organization)
                .FirstOrDefault(x => x.AcquisitionFileId == id) ?? throw new KeyNotFoundException();
        }

        /// <summary>
        /// Retrieves the acquisition file with the specified id last update information.
        /// </summary>
        /// <param name="id"></param>
        /// <returns></returns>
        public LastUpdatedByModel GetLastUpdateBy(long id)
        {
            // Acquisition File
            var lastUpdatedByAggregate = new List<LastUpdatedByModel>();
            var fileLastUpdatedBy = this.Context.PimsAcquisitionFiles.AsNoTracking()
                .Where(a => a.AcquisitionFileId == id)
                .Select(a => new LastUpdatedByModel()
                {
                    ParentId = id,
                    AppLastUpdateUserid = a.AppLastUpdateUserid,
                    AppLastUpdateUserGuid = a.AppLastUpdateUserGuid,
                    AppLastUpdateTimestamp = a.AppLastUpdateTimestamp,
                })
                .OrderByDescending(lu => lu.AppLastUpdateTimestamp)
                .Take(1)
                .ToList();
            lastUpdatedByAggregate.AddRange(fileLastUpdatedBy);

            // Acquisition Owners
            var ownersLastUpdatedBy = this.Context.PimsAcquisitionOwners.AsNoTracking()
                .Where(ao => ao.AcquisitionFileId == id)
                .Select(ao => new LastUpdatedByModel()
                {
                    ParentId = id,
                    AppLastUpdateUserid = ao.AppLastUpdateUserid,
                    AppLastUpdateUserGuid = ao.AppLastUpdateUserGuid,
                    AppLastUpdateTimestamp = ao.AppLastUpdateTimestamp,
                })
                .OrderByDescending(lu => lu.AppLastUpdateTimestamp)
                .Take(1)
                .ToList();
            lastUpdatedByAggregate.AddRange(ownersLastUpdatedBy);

            // Acquisition Deleted Owners
            var deletedOwners = this.Context.PimsAcquisitionOwnerHists.AsNoTracking()
               .Where(aph => aph.AcquisitionFileId == id)
               .GroupBy(aph => aph.AcquisitionOwnerId)
               .Select(gaph => gaph.OrderByDescending(a => a.EffectiveDateHist).FirstOrDefault()).ToList();

            var ownersHistLastUpdatedBy = deletedOwners
                .Select(aoh => new LastUpdatedByModel()
                {
                    ParentId = id,
                    AppLastUpdateUserid = aoh.AppLastUpdateUserid, // TODO: Update this once the DB tracks the user
                    AppLastUpdateUserGuid = aoh.AppLastUpdateUserGuid, // TODO: Update this once the DB tracks the user
                    AppLastUpdateTimestamp = aoh.EndDateHist ?? DateTime.UnixEpoch,
                })
                .OrderByDescending(lu => lu.AppLastUpdateTimestamp)
                .Take(1)
                .ToList();
            lastUpdatedByAggregate.AddRange(ownersHistLastUpdatedBy);

            // Acquisition Checklist items
            var checklistLastUpdatedBy = this.Context.PimsAcquisitionChecklistItems.AsNoTracking()
              .Where(ac => ac.AcquisitionFileId == id)
              .Select(ac => new LastUpdatedByModel()
              {
                  ParentId = id,
                  AppLastUpdateUserid = ac.AppLastUpdateUserid,
                  AppLastUpdateUserGuid = ac.AppLastUpdateUserGuid,
                  AppLastUpdateTimestamp = ac.AppLastUpdateTimestamp,
              })
              .OrderByDescending(lu => lu.AppLastUpdateTimestamp)
              .Take(1)
              .ToList();
            lastUpdatedByAggregate.AddRange(checklistLastUpdatedBy);

            // Acquisition Team
            var teamLastUpdatedBy = this.Context.PimsAcquisitionFileTeams.AsNoTracking()
              .Where(ap => ap.AcquisitionFileId == id)
              .Select(ap => new LastUpdatedByModel()
              {
                  ParentId = id,
                  AppLastUpdateUserid = ap.AppLastUpdateUserid,
                  AppLastUpdateUserGuid = ap.AppLastUpdateUserGuid,
                  AppLastUpdateTimestamp = ap.AppLastUpdateTimestamp,
              })
              .OrderByDescending(lu => lu.AppLastUpdateTimestamp)
              .Take(1)
              .ToList();
            lastUpdatedByAggregate.AddRange(teamLastUpdatedBy);

            // Acquisition Deleted Team
            // This is needed to get the acquisition team last-updated-by when deleted
            var deletedTeams = this.Context.PimsAcquisitionFileTeamHists.AsNoTracking()
                .Where(aph => aph.AcquisitionFileId == id)
                .GroupBy(aph => aph.AcquisitionFileTeamId)
                .Select(gaph => gaph.OrderByDescending(a => a.EffectiveDateHist).FirstOrDefault()).ToList();

            var teamHistLastUpdatedBy = deletedTeams
              .Select(aph => new LastUpdatedByModel()
              {
                  ParentId = id,
                  AppLastUpdateUserid = aph.AppLastUpdateUserid, // TODO: Update this once the DB tracks the user
                  AppLastUpdateUserGuid = aph.AppLastUpdateUserGuid, // TODO: Update this once the DB tracks the user
                  AppLastUpdateTimestamp = aph.EndDateHist ?? DateTime.UnixEpoch,
              })
              .OrderByDescending(lu => lu.AppLastUpdateTimestamp)
              .Take(1)
              .ToList();
            lastUpdatedByAggregate.AddRange(teamHistLastUpdatedBy);

            // Acquisition  Interest Holders
            var interestHolderLastUpdatedBy = this.Context.PimsInterestHolders.AsNoTracking()
              .Where(aih => aih.AcquisitionFileId == id)
              .Select(aih => new LastUpdatedByModel()
              {
                  ParentId = id,
                  AppLastUpdateUserid = aih.AppLastUpdateUserid,
                  AppLastUpdateUserGuid = aih.AppLastUpdateUserGuid,
                  AppLastUpdateTimestamp = aih.AppLastUpdateTimestamp,
              })
              .OrderByDescending(lu => lu.AppLastUpdateTimestamp)
              .Take(1)
              .ToList();
            lastUpdatedByAggregate.AddRange(interestHolderLastUpdatedBy);

            // Acquisition Deleted Interest Holders
            // This is needed to get the acquisition interest holder last-updated-by when deleted
            var deletedInterestHolders = this.Context.PimsInterestHolderHists.AsNoTracking()
                .Where(aph => aph.AcquisitionFileId == id)
                .GroupBy(aph => aph.InterestHolderId)
                .Select(gaph => gaph.OrderByDescending(a => a.EffectiveDateHist).FirstOrDefault()).ToList();

            var interestHolderHistLastUpdatedBy = deletedInterestHolders
              .Select(aihh => new LastUpdatedByModel()
              {
                  ParentId = id,
                  AppLastUpdateUserid = aihh.AppLastUpdateUserid, // TODO: Update this once the DB tracks the user
                  AppLastUpdateUserGuid = aihh.AppLastUpdateUserGuid, // TODO: Update this once the DB tracks the user
                  AppLastUpdateTimestamp = aihh.EndDateHist ?? DateTime.UnixEpoch,
              })
              .OrderByDescending(lu => lu.AppLastUpdateTimestamp)
              .Take(1)
              .ToList();
            lastUpdatedByAggregate.AddRange(interestHolderHistLastUpdatedBy);

            // Acquisition Documents
            var documentsLastUpdatedBy = this.Context.PimsAcquisitionFileDocuments.AsNoTracking()
                .Where(ad => ad.AcquisitionFileId == id)
                .Include(ad => ad.Document)
                .Select(ad => new LastUpdatedByModel()
                {
                    ParentId = id,
                    AppLastUpdateUserid = ad.Document.AppLastUpdateUserid,
                    AppLastUpdateUserGuid = ad.Document.AppLastUpdateUserGuid,
                    AppLastUpdateTimestamp = ad.Document.AppLastUpdateTimestamp,
                })
                .OrderByDescending(lu => lu.AppLastUpdateTimestamp)
                .Take(1)
                .ToList();
            lastUpdatedByAggregate.AddRange(documentsLastUpdatedBy);

            // Acquisition Deleted Documents
            // This is needed to get the document last-updated-by from the document that where deleted
            var deletedDocuments = this.Context.PimsAcquisitionFileDocumentHists.AsNoTracking()
                .Where(aph => aph.AcquisitionFileId == id)
                .GroupBy(aph => aph.AcquisitionFileDocumentId)
                .Select(gaph => gaph.OrderByDescending(a => a.EffectiveDateHist).FirstOrDefault()).ToList();

            var documentsHistoryLastUpdatedBy = deletedDocuments
                .Select(adh => new LastUpdatedByModel()
                {
                    ParentId = id,
                    AppLastUpdateUserid = adh.AppLastUpdateUserid, // TODO: Update this once the DB tracks the user
                    AppLastUpdateUserGuid = adh.AppLastUpdateUserGuid, // TODO: Update this once the DB tracks the user
                    AppLastUpdateTimestamp = adh.EndDateHist ?? DateTime.UnixEpoch,
                })
                .OrderByDescending(lu => lu.AppLastUpdateTimestamp)
                .Take(1)
                .ToList();
            lastUpdatedByAggregate.AddRange(documentsHistoryLastUpdatedBy);

            // Acquisition Notes
            var notesLastUpdatedBy = this.Context.PimsAcquisitionFileNotes.AsNoTracking()
                .Where(an => an.AcquisitionFileId == id)
                .Include(an => an.Note)
                .Select(an => new LastUpdatedByModel()
                {
                    ParentId = id,
                    AppLastUpdateUserid = an.Note.AppLastUpdateUserid,
                    AppLastUpdateUserGuid = an.Note.AppLastUpdateUserGuid,
                    AppLastUpdateTimestamp = an.Note.AppLastUpdateTimestamp,
                })
                .OrderByDescending(lu => lu.AppLastUpdateTimestamp)
                .Take(1)
                .ToList();
            lastUpdatedByAggregate.AddRange(notesLastUpdatedBy);

            // Acquisition Deleted Notes
            // This is needed to get the document last-updated-by from the document that where deleted
            var deletedNotes = this.Context.PimsAcquisitionFileNoteHists.AsNoTracking()
                .Where(aph => aph.AcquisitionFileId == id)
                .GroupBy(aph => aph.AcquisitionFileNoteId)
                .Select(gaph => gaph.OrderByDescending(a => a.EffectiveDateHist).FirstOrDefault()).ToList();

            var notesHistoryLastUpdatedBy = deletedNotes
                .Select(anh => new LastUpdatedByModel()
                {
                    ParentId = id,
                    AppLastUpdateUserid = anh.AppLastUpdateUserid, // TODO: Update this once the DB tracks the user
                    AppLastUpdateUserGuid = anh.AppLastUpdateUserGuid, // TODO: Update this once the DB tracks the user
                    AppLastUpdateTimestamp = anh.EndDateHist ?? DateTime.UnixEpoch,
                })
                .OrderByDescending(lu => lu.AppLastUpdateTimestamp)
                .Take(1)
                .ToList();
            lastUpdatedByAggregate.AddRange(notesHistoryLastUpdatedBy);

            // Acquisition Properties
            var propertiesLastUpdatedBy = this.Context.PimsPropertyAcquisitionFiles.AsNoTracking()
                .Where(ap => ap.AcquisitionFileId == id)
                .Select(ap => new LastUpdatedByModel()
                {
                    ParentId = id,
                    AppLastUpdateUserid = ap.AppLastUpdateUserid,
                    AppLastUpdateUserGuid = ap.AppLastUpdateUserGuid,
                    AppLastUpdateTimestamp = ap.AppLastUpdateTimestamp,
                })
                .OrderByDescending(lu => lu.AppLastUpdateTimestamp)
                .Take(1)
                .ToList();
            lastUpdatedByAggregate.AddRange(propertiesLastUpdatedBy);

            // Acquisition Deleted Properties
            // This is needed to get the notes last-updated-by from the notes that where deleted
            var deletedProperties = this.Context.PimsPropertyAcquisitionFileHists.AsNoTracking()
               .Where(aph => aph.AcquisitionFileId == id)
               .GroupBy(aph => aph.PropertyAcquisitionFileId)
               .Select(gaph => gaph.OrderByDescending(a => a.EffectiveDateHist).FirstOrDefault()).ToList();

            var propertiesHistoryLastUpdatedBy = deletedProperties
            .Select(aph => new LastUpdatedByModel()
            {
                ParentId = id,
                AppLastUpdateUserid = aph.AppLastUpdateUserid, // TODO: Update this once the DB tracks the user
                AppLastUpdateUserGuid = aph.AppLastUpdateUserGuid, // TODO: Update this once the DB tracks the user
                AppLastUpdateTimestamp = aph.EndDateHist ?? DateTime.UnixEpoch,
            })
            .OrderByDescending(lu => lu.AppLastUpdateTimestamp)
            .Take(1)
            .ToList();
            lastUpdatedByAggregate.AddRange(propertiesHistoryLastUpdatedBy);

            // Acquisition Takes
            var takesLastUpdatedBy = this.Context.PimsTakes.AsNoTracking()
                .Include(at => at.PropertyAcquisitionFile)
                .Where(at => at.PropertyAcquisitionFile.AcquisitionFileId == id)
                .Select(apt => new LastUpdatedByModel()
                {
                    ParentId = id,
                    AppLastUpdateUserid = apt.AppLastUpdateUserid,
                    AppLastUpdateUserGuid = apt.AppLastUpdateUserGuid,
                    AppLastUpdateTimestamp = apt.AppLastUpdateTimestamp,
                })
                .OrderByDescending(lu => lu.AppLastUpdateTimestamp)
                .Take(1)
                .ToList();
            lastUpdatedByAggregate.AddRange(takesLastUpdatedBy);

            // Acquisition Deleted Takes
            // This is needed to get the notes last-updated-by from the notes that where deleted
            var takeHists = this.Context.PimsTakeHists.AsNoTracking();
            var deletedTakes = this.Context.PimsPropertyAcquisitionFileHists.AsNoTracking()
            .Where(at => at.AcquisitionFileId == id)
            .Join(
                    takeHists,
                    propAcqHist => propAcqHist.PropertyAcquisitionFileId,
                    takeHist => takeHist.PropertyAcquisitionFileId,
                    (acqPropHist, takeHist) => takeHist)
                .GroupBy(aph => aph.TakeId)
                .Select(gaph => gaph.OrderByDescending(a => a.EffectiveDateHist).FirstOrDefault()).ToList();

            var takesHistoryLastUpdatedBy = deletedTakes
            .Select(rdh => new LastUpdatedByModel()
            {
                ParentId = id,
                AppLastUpdateUserid = rdh.AppLastUpdateUserid, // TODO: Update this once the DB tracks the user
                AppLastUpdateUserGuid = rdh.AppLastUpdateUserGuid, // TODO: Update this once the DB tracks the user
                AppLastUpdateTimestamp = rdh.EndDateHist ?? DateTime.UnixEpoch,
            })
            .OrderByDescending(lu => lu.AppLastUpdateTimestamp)
            .Take(1)
            .ToList();
            lastUpdatedByAggregate.AddRange(takesHistoryLastUpdatedBy);

            // Acquisition Compensation Requisition
            var compensationLastUpdatedBy = this.Context.PimsCompensationRequisitions.AsNoTracking()
                .Where(acr => acr.AcquisitionFileId == id)
                .Select(acr => new LastUpdatedByModel()
                {
                    ParentId = id,
                    AppLastUpdateUserid = acr.AppLastUpdateUserid,
                    AppLastUpdateUserGuid = acr.AppLastUpdateUserGuid,
                    AppLastUpdateTimestamp = acr.AppLastUpdateTimestamp,
                })
                .OrderByDescending(lu => lu.AppLastUpdateTimestamp)
                .Take(1)
                .ToList();
            lastUpdatedByAggregate.AddRange(compensationLastUpdatedBy);

            // Acquisition Deleted Compensation Requisition
            // This is needed to get the notes last-updated-by from the notes that where deleted
            var deletedCompReqs = this.Context.PimsCompensationRequisitionHists.AsNoTracking()
                .Where(aph => aph.AcquisitionFileId == id)
                .GroupBy(aph => aph.CompensationRequisitionId)
                .Select(gaph => gaph.OrderByDescending(a => a.EffectiveDateHist).FirstOrDefault()).ToList();

            var compensationHistoryLastUpdatedBy = deletedCompReqs
            .Select(acrh => new LastUpdatedByModel()
            {
                ParentId = id,
                AppLastUpdateUserid = acrh.AppLastUpdateUserid, // TODO: Update this once the DB tracks the user
                AppLastUpdateUserGuid = acrh.AppLastUpdateUserGuid, // TODO: Update this once the DB tracks the user
                AppLastUpdateTimestamp = acrh.EndDateHist ?? DateTime.UnixEpoch,
            })
            .OrderByDescending(lu => lu.AppLastUpdateTimestamp)
            .Take(1)
            .ToList();
            lastUpdatedByAggregate.AddRange(compensationHistoryLastUpdatedBy);

            // Acquisition Compensation Requsition Financials
            var financialsLastUpdatedBy = this.Context.PimsCompReqFinancials.AsNoTracking()
                .Include(acrf => acrf.CompensationRequisition)
                .Where(acrf => acrf.CompensationRequisition.AcquisitionFileId == id)
                .Select(acrf => new LastUpdatedByModel()
                {
                    ParentId = id,
                    AppLastUpdateUserid = acrf.AppLastUpdateUserid,
                    AppLastUpdateUserGuid = acrf.AppLastUpdateUserGuid,
                    AppLastUpdateTimestamp = acrf.AppLastUpdateTimestamp,
                })
                .OrderByDescending(lu => lu.AppLastUpdateTimestamp)
                .Take(1)
                .ToList();
            lastUpdatedByAggregate.AddRange(financialsLastUpdatedBy);

            // Acquisition Deleted Compensation Requsition Financials
            // This is needed to get the notes last-updated-by from the notes that where deleted
            var financialHists = this.Context.PimsCompReqFinancialHists.AsNoTracking();
            var deletedCompReqFinancials = this.Context.PimsCompensationRequisitionHists.AsNoTracking()
            .Where(at => at.AcquisitionFileId == id)
            .Join(
                    financialHists,
                    compReqHist => compReqHist.CompensationRequisitionId,
                    financialHist => financialHist.CompensationRequisitionId,
                    (compReqHist, compReqFinHist) => compReqFinHist)
                .GroupBy(aph => aph.CompReqFinancialId)
                .Select(gaph => gaph.OrderByDescending(a => a.EffectiveDateHist).FirstOrDefault()).ToList();

            var compreqHistoryLastUpdatedBy = deletedCompReqFinancials
            .Select(rdh => new LastUpdatedByModel()
            {
                ParentId = id,
                AppLastUpdateUserid = rdh.AppLastUpdateUserid, // TODO: Update this once the DB tracks the user
                AppLastUpdateUserGuid = rdh.AppLastUpdateUserGuid, // TODO: Update this once the DB tracks the user
                AppLastUpdateTimestamp = rdh.EndDateHist ?? DateTime.UnixEpoch,
            })
            .OrderByDescending(lu => lu.AppLastUpdateTimestamp)
            .Take(1)
            .ToList();
            lastUpdatedByAggregate.AddRange(compreqHistoryLastUpdatedBy);

            // Acquisition Expropiation Payments
            var expPaymentsLastUpdatedBy = this.Context.PimsExpropriationPayments.AsNoTracking()
                .Where(aep => aep.AcquisitionFileId == id)
                .Select(aep => new LastUpdatedByModel()
                {
                    ParentId = id,
                    AppLastUpdateUserid = aep.AppLastUpdateUserid,
                    AppLastUpdateUserGuid = aep.AppLastUpdateUserGuid,
                    AppLastUpdateTimestamp = aep.AppLastUpdateTimestamp,
                })
                .OrderByDescending(lu => lu.AppLastUpdateTimestamp)
                .Take(1)
                .ToList();
            lastUpdatedByAggregate.AddRange(expPaymentsLastUpdatedBy);

            // Acquisition Deleted Expropiation Payments
            // This is needed to get the notes last-updated-by from the notes that where deleted
            var deletedExpropiationPayments = this.Context.PimsExpropriationPaymentHists.AsNoTracking()
                .Where(aph => aph.AcquisitionFileId == id)
                .GroupBy(aph => aph.ExpropriationPaymentId)
                .Select(gaph => gaph.OrderByDescending(a => a.EffectiveDateHist).FirstOrDefault()).ToList();

            var expPaymentsHistoryLastUpdatedBy = deletedExpropiationPayments
            .Select(aeph => new LastUpdatedByModel()
            {
                ParentId = id,
                AppLastUpdateUserid = aeph.AppLastUpdateUserid, // TODO: Update this once the DB tracks the user
                AppLastUpdateUserGuid = aeph.AppLastUpdateUserGuid, // TODO: Update this once the DB tracks the user
                AppLastUpdateTimestamp = aeph.EndDateHist ?? DateTime.UnixEpoch,
            })
            .OrderByDescending(lu => lu.AppLastUpdateTimestamp)
            .Take(1)
            .ToList();
            lastUpdatedByAggregate.AddRange(expPaymentsHistoryLastUpdatedBy);

            // Acquisition Expropiation payments
            var expPaymentsItemsLastUpdatedBy = this.Context.PimsExpropPmtPmtItems.AsNoTracking()
                .Include(aepi => aepi.ExpropriationPayment)
                .Where(aepi => aepi.ExpropriationPayment.AcquisitionFileId == id)
                .Select(aepi => new LastUpdatedByModel()
                {
                    ParentId = id,
                    AppLastUpdateUserid = aepi.AppLastUpdateUserid,
                    AppLastUpdateUserGuid = aepi.AppLastUpdateUserGuid,
                    AppLastUpdateTimestamp = aepi.AppLastUpdateTimestamp,
                })
                .OrderByDescending(lu => lu.AppLastUpdateTimestamp)
                .Take(1)
                .ToList();
            lastUpdatedByAggregate.AddRange(expPaymentsItemsLastUpdatedBy);

            // Acquisition Deleted Expropiation payments
            // This is needed to get the notes last-updated-by from the notes that where deleted
            var expItemHists = this.Context.PimsExpropPmtPmtItemHists.AsNoTracking();
            var deletedPaymentItems = this.Context.PimsExpropriationPaymentHists.AsNoTracking()
            .Where(at => at.AcquisitionFileId == id)
            .Join(
                    expItemHists,
                    expPaymentHist => expPaymentHist.ExpropriationPaymentId,
                    expItemHist => expItemHist.ExpropriationPaymentId,
                    (expPaymentHist, expItemHist) => expItemHist)
                .GroupBy(aph => aph.ExpropPmtPmtItemId)
                .Select(gaph => gaph.OrderByDescending(a => a.EffectiveDateHist).FirstOrDefault()).ToList();

            var expHistoryLastUpdatedBy = deletedPaymentItems
            .Select(rdh => new LastUpdatedByModel()
            {
                ParentId = id,
                AppLastUpdateUserid = rdh.AppLastUpdateUserid, // TODO: Update this once the DB tracks the user
                AppLastUpdateUserGuid = rdh.AppLastUpdateUserGuid, // TODO: Update this once the DB tracks the user
                AppLastUpdateTimestamp = rdh.EndDateHist ?? DateTime.UnixEpoch,
            })
            .OrderByDescending(lu => lu.AppLastUpdateTimestamp)
            .Take(1)
            .ToList();
            lastUpdatedByAggregate.AddRange(expHistoryLastUpdatedBy);

            // Acquisition Agreements
            var agreementsLastUpdatedBy = this.Context.PimsAgreements.AsNoTracking()
                .Where(aa => aa.AcquisitionFileId == id)
                .Select(aa => new LastUpdatedByModel()
                {
                    ParentId = id,
                    AppLastUpdateUserid = aa.AppLastUpdateUserid,
                    AppLastUpdateUserGuid = aa.AppLastUpdateUserGuid,
                    AppLastUpdateTimestamp = aa.AppLastUpdateTimestamp,
                })
                .OrderByDescending(lu => lu.AppLastUpdateTimestamp)
                .Take(1)
                .ToList();
            lastUpdatedByAggregate.AddRange(agreementsLastUpdatedBy);

            // Acquisition Deleted Agreements
            // This is needed to get the notes last-updated-by from the notes that where deleted
            var deletedAgreements = this.Context.PimsAgreementHists.AsNoTracking()
                .Where(aph => aph.AcquisitionFileId == id)
                .GroupBy(aph => aph.AgreementId)
                .Select(gaph => gaph.OrderByDescending(a => a.EffectiveDateHist).FirstOrDefault()).ToList();

            var agreementsHistoryLastUpdatedBy = deletedAgreements
            .Select(aah => new LastUpdatedByModel()
            {
                ParentId = id,
                AppLastUpdateUserid = aah.AppLastUpdateUserid, // TODO: Update this once the DB tracks the user
                AppLastUpdateUserGuid = aah.AppLastUpdateUserGuid, // TODO: Update this once the DB tracks the user
                AppLastUpdateTimestamp = aah.EndDateHist ?? DateTime.UnixEpoch,
            })
            .OrderByDescending(lu => lu.AppLastUpdateTimestamp)
            .Take(1)
            .ToList();
            lastUpdatedByAggregate.AddRange(agreementsHistoryLastUpdatedBy);

            return lastUpdatedByAggregate.OrderByDescending(x => x.AppLastUpdateTimestamp).FirstOrDefault();
        }

        public List<PimsAcquisitionOwner> GetOwnersByAcquisitionFileId(long acquisitionFileId)
        {
            return Context.PimsAcquisitionOwners
                .Where(x => x.AcquisitionFileId == acquisitionFileId)
                .Include(x => x.Address)
                    .ThenInclude(x => x.RegionCodeNavigation)
                .Include(x => x.Address)
                    .ThenInclude(x => x.Country)
                .Include(x => x.Address)
                    .ThenInclude(x => x.ProvinceState)
                .Include(x => x.Address)
                    .ThenInclude(x => x.DistrictCodeNavigation)
                .AsNoTracking()
                .ToList();
        }

        public List<PimsAcquisitionFileTeam> GetTeamMembers(HashSet<short> regions, long? contractorPersonId = null)
        {
            var predicate = PredicateBuilder.New<PimsAcquisitionFileTeam>(acq => true);

            predicate.And(x => regions.Contains(x.AcquisitionFile.RegionCode));

            if (contractorPersonId != null)
            {
                predicate.And(x => x.AcquisitionFile.PimsAcquisitionFileTeams.Any(p => p.PersonId == contractorPersonId));
            }

            return Context.PimsAcquisitionFileTeams.AsNoTracking()
                .Include(x => x.AcquisitionFile)
                .Include(x => x.Person)
                .Include(x => x.Organization)
                .Where(predicate)
                .ToList();
        }

        /// <summary>
        /// Adds the specified acquisition file to the datasource.
        /// </summary>
        /// <param name="acquisitionFile"></param>
        /// <returns></returns>
        public PimsAcquisitionFile Add(PimsAcquisitionFile acquisitionFile)
        {
            using var scope = Logger.QueryScope();
            acquisitionFile.ThrowIfNull(nameof(acquisitionFile));

            if (acquisitionFile.PimsPropertyAcquisitionFiles.Any(x => x.Property != null && x.Property.IsRetired.HasValue && x.Property.IsRetired.Value))
            {
                throw new BusinessRuleViolationException("Retired property can not be selected.");
            }

            // Existing properties should not be added.
            foreach (var acquisitionProperty in acquisitionFile.PimsPropertyAcquisitionFiles)
            {
                if (acquisitionProperty.Property.Internal_Id != 0)
                {
                    acquisitionProperty.Property = null;
                }
            }

            if (acquisitionFile.PrntAcquisitionFileId is null)
            {
                // generate file number for "main" files
                int nextFileNo = GetNextAcquisitionFileNumberSequenceValue();
                acquisitionFile.FileNo = nextFileNo;
                acquisitionFile.FileNoSuffix = 1;
            }
            else
            {
                // generate file number for "sub-files"
                var parentFile = Context.PimsAcquisitionFiles.AsNoTracking()
                    .FirstOrDefault(x => x.AcquisitionFileId == acquisitionFile.PrntAcquisitionFileId) ?? throw new KeyNotFoundException();

                var nextSuffix = GetNextSubFileSuffixValue(parentFile.Internal_Id);
                acquisitionFile.FileNo = parentFile.FileNo;
                acquisitionFile.FileNoSuffix = nextSuffix;
            }

            Context.PimsAcquisitionFiles.Add(acquisitionFile);
            return acquisitionFile;
        }

        /// <summary>
        /// Updates the specified acquisition file.
        /// </summary>
        /// <param name="acquisitionFile"></param>
        /// <returns></returns>
        public PimsAcquisitionFile Update(PimsAcquisitionFile acquisitionFile)
        {
            using var scope = Logger.QueryScope();
            acquisitionFile.ThrowIfNull(nameof(acquisitionFile));

            var existingAcqFile = Context.PimsAcquisitionFiles
                .FirstOrDefault(x => x.AcquisitionFileId == acquisitionFile.Internal_Id) ?? throw new KeyNotFoundException();

            // Make sure the frontend cannot override these auto-generated fields
            acquisitionFile.FileNo = existingAcqFile.FileNo;
            acquisitionFile.FileNoSuffix = existingAcqFile.FileNoSuffix;

            // PSP-9268 Changes to Project/Product on the main file need to be propagated to all sub-files
            if (existingAcqFile.ProjectId != acquisitionFile.ProjectId || existingAcqFile.ProductId != acquisitionFile.ProductId)
            {
                var allRegions = Context.PimsRegions.AsNoTracking().Select(r => r.RegionCode).ToHashSet();
                var subFiles = GetAcquisitionSubFiles(existingAcqFile.Internal_Id, allRegions);
                foreach (var subFile in subFiles)
                {
                    subFile.ProjectId = acquisitionFile.ProjectId;
                    subFile.ProductId = acquisitionFile.ProductId;
                    Context.Entry(subFile).State = EntityState.Modified;
                    Context.Entry(subFile).Property(x => x.ProjectId).IsModified = true;
                    Context.Entry(subFile).Property(x => x.ProductId).IsModified = true;
                }
            }

            Context.Entry(existingAcqFile).CurrentValues.SetValues(acquisitionFile);
            Context.UpdateChild<PimsAcquisitionFile, long, PimsAcquisitionFileTeam, long>(p => p.PimsAcquisitionFileTeams, acquisitionFile.Internal_Id, acquisitionFile.PimsAcquisitionFileTeams.ToArray());
            Context.UpdateChild<PimsAcquisitionFile, long, PimsInterestHolder, long>(p => p.PimsInterestHolders, acquisitionFile.Internal_Id, acquisitionFile.PimsInterestHolders.ToArray());
            Context.UpdateGrandchild<PimsAcquisitionFile, long, PimsAcquisitionOwner>(o => o.PimsAcquisitionOwners, oa => oa.Address, acquisitionFile.Internal_Id, acquisitionFile.PimsAcquisitionOwners.ToArray());
            Context.UpdateChild<PimsAcquisitionFile, long, PimsAcqFileAcqProgress, long>(p => p.PimsAcqFileAcqProgresses, acquisitionFile.AcquisitionFileId, acquisitionFile.PimsAcqFileAcqProgresses.ToArray());
            Context.UpdateChild<PimsAcquisitionFile, long, PimsAcqFileAcqFlTakeTyp, long>(p => p.PimsAcqFileAcqFlTakeTyps, acquisitionFile.AcquisitionFileId, acquisitionFile.PimsAcqFileAcqFlTakeTyps.ToArray());

            return acquisitionFile;
        }

        /// <summary>
        /// Retrieves the version of the acquisition file with the specified id.
        /// </summary>
        /// <param name="id"></param>
        /// <returns>The file row version.</returns>
        public long GetRowVersion(long id)
        {
            using var scope = Logger.QueryScope();

            return this.Context.PimsAcquisitionFiles.AsNoTracking()
                .Where(p => p.AcquisitionFileId == id)?
                .Select(p => p.ConcurrencyControlNumber)?
                .FirstOrDefault() ?? throw new KeyNotFoundException();
        }

        /// <summary>
        /// Retrieves the region of the acquisition file with the specified id.
        /// </summary>
        /// <param name="id"></param>
        /// <returns>The file region.</returns>
        public short GetRegion(long id)
        {
            using var scope = Logger.QueryScope();

            return this.Context.PimsAcquisitionFiles.AsNoTracking()
                .Where(p => p.AcquisitionFileId == id)?
                .Select(p => p.RegionCode)?
                .FirstOrDefault() ?? throw new KeyNotFoundException();
        }

        public List<PimsAcquisitionFile> GetByProductId(long productId)
        {
            return this.Context.PimsAcquisitionFiles.AsNoTracking()
                .Where(a => a.ProductId == productId).ToList();
        }

        public PimsAcquisitionFile GetByAcquisitionFilePropertyId(long acquisitionFilePropertyId)
        {
            return this.Context.PimsAcquisitionFiles.AsNoTracking()
                .FirstOrDefault(a => a.PimsPropertyAcquisitionFiles.Any(x => x.PropertyAcquisitionFileId == acquisitionFilePropertyId));
        }

        public PimsProperty GetProperty(long acquisitionFilePropertyId)
        {
            return this.Context.PimsPropertyAcquisitionFiles.AsNoTracking()
                .Include(p => p.Property)
                .Where(p => p.PropertyAcquisitionFileId == acquisitionFilePropertyId)
                .Select(p => p.Property)
                .FirstOrDefault();
        }

        public List<PimsAcquisitionFile> GetAcquisitionSubFiles(long acquisitionFileId, HashSet<short> regions, long? contractorPersonId = null)
        {
            var predicate = PredicateBuilder.New<PimsAcquisitionFile>(acq => true);

            predicate.And(acq => acq.PrntAcquisitionFileId == acquisitionFileId);

            predicate = predicate.And(acq => regions.Contains(acq.RegionCode));

            if (contractorPersonId is not null)
            {
                predicate = predicate.And(acq => acq.PimsAcquisitionFileTeams.Any(x => x.PersonId == contractorPersonId));
            }

            return Context.PimsAcquisitionFiles.AsNoTracking()
                .Include(s => s.AcquisitionFileStatusTypeCodeNavigation)
                .Where(predicate).OrderBy(x => x.FileNoSuffix).ToList();
        }

        /// <summary>
        /// Get the next available value from PIMS_ACQUISITION_FILE_NO_SEQ.
        /// </summary>
        /// <returns>The next value for the sequence.</returns>
        private int GetNextAcquisitionFileNumberSequenceValue()
        {
            return (int)_sequenceRepository.GetNextSequenceValue("dbo.PIMS_ACQUISITION_FILE_NO_SEQ");
        }

        private short GetNextSubFileSuffixValue(long parentAcquisitionFileId)
        {
            // To determine the next suffix number we need to grab all sub-files (regardless of any region restriction)
            var allRegions = Context.PimsRegions.AsNoTracking().Select(r => r.RegionCode).ToHashSet();

            // The suffix numbers for sub-interest files start from "02", and will increment by 1 for sub-sequent file in the order of creation.
            var existingSubFiles = GetAcquisitionSubFiles(parentAcquisitionFileId, allRegions);
            if (existingSubFiles.Count == 0)
            {
                return 2;
            }
            else
            {
                short maxSuffix = existingSubFiles.Select(x => x.FileNoSuffix).Max();
                return (short)(maxSuffix + 1);
            }
        }

        /// <summary>
        /// Generate a common IQueryable for Acquisition Files.
        /// </summary>
        /// <param name="filter"></param>
        /// <param name="regions"></param>
        /// <param name="contractorPersonId"></param>
        /// <returns></returns>
        private IQueryable<PimsAcquisitionFile> GetCommonAcquisitionFileQueryDeep(AcquisitionFilter filter, HashSet<short> regions, long? contractorPersonId = null)
        {
            var predicate = PredicateBuilder.New<PimsAcquisitionFile>(acq => true);

            if (!string.IsNullOrWhiteSpace(filter.Pid))
            {
                var pidValue = filter.Pid.Replace("-", string.Empty).Trim().TrimStart('0');
                predicate = predicate.And(acq => acq.PimsPropertyAcquisitionFiles.Any(pa => pa != null && EF.Functions.Like(pa.Property.Pid.ToString(), $"%{pidValue}%")));
            }

            if (!string.IsNullOrWhiteSpace(filter.Pin))
            {
                var pinValue = filter.Pin.Replace("-", string.Empty).Trim().TrimStart('0');
                predicate = predicate.And(acq => acq.PimsPropertyAcquisitionFiles.Any(pa => pa != null && EF.Functions.Like(pa.Property.Pin.ToString(), $"%{pinValue}%")));
            }

            if (!string.IsNullOrWhiteSpace(filter.Address))
            {
                predicate = predicate.And(acq => acq.PimsPropertyAcquisitionFiles.Any(pa => pa != null &&
                    (EF.Functions.Like(pa.Property.Address.StreetAddress1, $"%{filter.Address}%") ||
                    EF.Functions.Like(pa.Property.Address.StreetAddress2, $"%{filter.Address}%") ||
                    EF.Functions.Like(pa.Property.Address.StreetAddress3, $"%{filter.Address}%") ||
                    EF.Functions.Like(pa.Property.Address.MunicipalityName, $"%{filter.Address}%"))));
            }

            if (!string.IsNullOrWhiteSpace(filter.AcquisitionFileStatusTypeCode))
            {
                predicate = predicate.And(acq => acq.AcquisitionFileStatusTypeCode == filter.AcquisitionFileStatusTypeCode);
            }

            if (!string.IsNullOrWhiteSpace(filter.AcquisitionFileNameOrNumber))
            {
                var fileNumberBuilder = PredicateBuilder.New<PimsAcquisitionFile>(acq => false);
                fileNumberBuilder = fileNumberBuilder.Or(r => EF.Functions.Like((r.RegionCode < 10 ? "0" : string.Empty) + r.RegionCode.ToString() + "-" + r.FileNo.ToString() + "-" + (r.FileNoSuffix < 10 ? "0" : string.Empty) + r.FileNoSuffix.ToString(), $"%{filter.AcquisitionFileNameOrNumber}%"));
                fileNumberBuilder = fileNumberBuilder.Or(r => EF.Functions.Like(r.FileName, $"%{filter.AcquisitionFileNameOrNumber}%"));
                fileNumberBuilder = fileNumberBuilder.Or(r => EF.Functions.Like(r.LegacyFileNumber, $"%{filter.AcquisitionFileNameOrNumber}%"));

                predicate = predicate.And(fileNumberBuilder);
            }

            if (!string.IsNullOrWhiteSpace(filter.ProjectNameOrNumber))
            {
                predicate = predicate.And(acq => EF.Functions.Like(acq.Project.Code, $"%{filter.ProjectNameOrNumber}%") || EF.Functions.Like(acq.Project.Description, $"%{filter.ProjectNameOrNumber}%")
                || acq.PimsCompensationRequisitions.Any(cr => EF.Functions.Like(cr.AlternateProject.Code, $"%{filter.ProjectNameOrNumber}%") || EF.Functions.Like(cr.AlternateProject.Description, $"%{filter.ProjectNameOrNumber}%")));
            }

            predicate = predicate.And(acq => regions.Contains(acq.RegionCode));

            if (contractorPersonId is not null)
            {
                predicate = predicate.And(acq => acq.PimsAcquisitionFileTeams.Any(x => x.PersonId == contractorPersonId) || (acq.Project != null && acq.Project.PimsProjectPeople.Any(x => x.PersonId == contractorPersonId)));
            }

            if (!string.IsNullOrWhiteSpace(filter.AcquisitionTeamMemberPersonId))
            {
                predicate = predicate.And(acq => acq.PimsAcquisitionFileTeams.Any(x => x.PersonId == long.Parse(filter.AcquisitionTeamMemberPersonId)));
            }

            if (!string.IsNullOrWhiteSpace(filter.AcquisitionTeamMemberOrganizationId))
            {
                predicate = predicate.And(acq => acq.PimsAcquisitionFileTeams.Any(x => x.OrganizationId == long.Parse(filter.AcquisitionTeamMemberOrganizationId)));
            }

            var query = Context.PimsAcquisitionFiles.AsNoTracking()
                .Include(r => r.RegionCodeNavigation)
                .Include(p => p.Project)
                    .ThenInclude(p => p.PimsProjectPeople)
                .Include(s => s.AcquisitionFileStatusTypeCodeNavigation)
                .Include(f => f.AcquisitionFundingTypeCodeNavigation)
                .Include(ph => ph.AcqPhysFileStatusTypeCodeNavigation)
                .Include(t => t.AcquisitionTypeCodeNavigation)
                .Include(tm => tm.PimsAcquisitionFileTeams)
                    .ThenInclude(c => c.Person)
                .Include(tm => tm.PimsAcquisitionFileTeams)
                    .ThenInclude(c => c.Organization)
                .Include(tm => tm.PimsAcquisitionFileTeams)
                    .ThenInclude(c => c.AcqFlTeamProfileTypeCodeNavigation)
                .Include(ow => ow.PimsAcquisitionOwners)
                .Include(fp => fp.PimsPropertyAcquisitionFiles)
                    .ThenInclude(prop => prop.Property)
                    .ThenInclude(ad => ad.Address)
                    .ThenInclude(x => x.ProvinceState)
                .Include(fp => fp.PimsPropertyAcquisitionFiles)
                    .ThenInclude(prop => prop.Property)
                    .ThenInclude(ad => ad.Address)
                    .ThenInclude(x => x.Country)
                .Include(fp => fp.PimsCompensationRequisitions)
                    .ThenInclude(fp => fp.AlternateProject)
                .Where(predicate);

            if (filter.Sort?.Length > 0 && filter.Sort[0].Contains("FileNumber"))
            {
                query = filter.Sort[0].Contains("asc") ? query.OrderBy(acq => acq.RegionCode)
                    .ThenBy(acq => acq.FileNo)
                    .ThenBy(acq => acq.FileNoSuffix) : query.OrderByDescending(acq => acq.RegionCode)
                    .ThenByDescending(acq => acq.FileNo)
                    .ThenByDescending(acq => acq.FileNoSuffix);
            }
            else
            {
                query = (filter.Sort?.Length > 0) ? query.OrderByProperty(true, filter.Sort) : query.OrderBy(acq => acq.AcquisitionFileId);
            }

            return query;
        }

        #endregion
    }
}
