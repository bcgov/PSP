-- Script generated by Aqua Data Studio Schema Synchronization for MS SQL Server 2016 on Wed Nov 17 13:00:16 PST 2021
-- Execute this script on:
-- 		PIMS_S15_00/<All Schemas> - This database/schema will be modified
-- to synchronize it with MS SQL Server 2016:
-- 		PIMS_S15_01/<All Schemas>

-- We recommend backing up the database prior to executing the script.

SET XACT_ABORT ON
GO
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE
GO
BEGIN TRANSACTION
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Drop trigger dbo.PIMS_SECDEP_I_S_I_TR
PRINT N'Drop trigger dbo.PIMS_SECDEP_I_S_I_TR'
GO
DROP TRIGGER [dbo].[PIMS_SECDEP_I_S_I_TR]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Drop trigger dbo.PIMS_SECDEP_A_S_IUD_TR
PRINT N'Drop trigger dbo.PIMS_SECDEP_A_S_IUD_TR'
GO
DROP TRIGGER [dbo].[PIMS_SECDEP_A_S_IUD_TR]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Drop trigger dbo.PIMS_SDRTRN_A_S_IUD_TR
PRINT N'Drop trigger dbo.PIMS_SDRTRN_A_S_IUD_TR'
GO
DROP TRIGGER [dbo].[PIMS_SDRTRN_A_S_IUD_TR]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Drop trigger dbo.PIMS_LEASE_A_S_IUD_TR
PRINT N'Drop trigger dbo.PIMS_LEASE_A_S_IUD_TR'
GO
DROP TRIGGER [dbo].[PIMS_LEASE_A_S_IUD_TR]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Drop trigger dbo.PIMS_SECDEP_I_S_U_TR
PRINT N'Drop trigger dbo.PIMS_SECDEP_I_S_U_TR'
GO
DROP TRIGGER [dbo].[PIMS_SECDEP_I_S_U_TR]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Drop trigger dbo.PIMS_PIDSRT_I_S_U_TR
PRINT N'Drop trigger dbo.PIMS_PIDSRT_I_S_U_TR'
GO
DROP TRIGGER [dbo].[PIMS_PIDSRT_I_S_U_TR]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Drop trigger dbo.PIMS_PIDSRT_I_S_I_TR
PRINT N'Drop trigger dbo.PIMS_PIDSRT_I_S_I_TR'
GO
DROP TRIGGER [dbo].[PIMS_PIDSRT_I_S_I_TR]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Drop trigger dbo.PIMS_SDRTRN_I_S_U_TR
PRINT N'Drop trigger dbo.PIMS_SDRTRN_I_S_U_TR'
GO
DROP TRIGGER [dbo].[PIMS_SDRTRN_I_S_U_TR]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Drop trigger dbo.PIMS_LEASE_I_S_U_TR
PRINT N'Drop trigger dbo.PIMS_LEASE_I_S_U_TR'
GO
DROP TRIGGER [dbo].[PIMS_LEASE_I_S_U_TR]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Drop trigger dbo.PIMS_SDRTRN_I_S_I_TR
PRINT N'Drop trigger dbo.PIMS_SDRTRN_I_S_I_TR'
GO
DROP TRIGGER [dbo].[PIMS_SDRTRN_I_S_I_TR]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Drop trigger dbo.PIMS_PROJCT_A_S_IUD_TR
PRINT N'Drop trigger dbo.PIMS_PROJCT_A_S_IUD_TR'
GO
DROP TRIGGER [dbo].[PIMS_PROJCT_A_S_IUD_TR]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Drop trigger dbo.PIMS_LEASE_I_S_I_TR
PRINT N'Drop trigger dbo.PIMS_LEASE_I_S_I_TR'
GO
DROP TRIGGER [dbo].[PIMS_LEASE_I_S_I_TR]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Drop foreign key constraint PIM_PIDSRT_PIM_PRPRTY_FK
PRINT N'Drop foreign key constraint PIM_PIDSRT_PIM_PRPRTY_FK'
GO
ALTER TABLE [dbo].[PIMS_PROPERTY]
	DROP CONSTRAINT [PIM_PIDSRT_PIM_PRPRTY_FK]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Drop primary key constraint PIDSRT_PK
PRINT N'Drop primary key constraint PIDSRT_PK'
GO
ALTER TABLE [dbo].[PIMS_PROPERTY_DATA_SOURCE_TYPE]
	DROP CONSTRAINT [PIDSRT_PK]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Drop procedure dbo.pims_error_handling
PRINT N'Drop procedure dbo.pims_error_handling'
GO
DROP PROCEDURE [dbo].[pims_error_handling]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Drop function dbo.pims_ColumnExists
PRINT N'Drop function dbo.pims_ColumnExists'
GO
DROP FUNCTION [dbo].[pims_ColumnExists]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create function dbo.pims_ColumnExists
PRINT N'Create function dbo.pims_ColumnExists'
GO
-- --------------------------------------------------------------------------------------------
-- Create function pims_ColumnExists 
-- --------------------------------------------------------------------------------------------
CREATE FUNCTION [dbo].[pims_ColumnExists](@TableName varchar(100), @ColumnName varchar(100))
RETURNS nvarchar(1) 
AS
BEGIN
  DECLARE @Result nvarchar(1);
  
  IF EXISTS (SELECT * FROM INFORMATION_SCHEMA.Columns WHERE TABLE_NAME = @TableName AND COLUMN_NAME = @ColumnName)
    SET @Result = 'Y'
  ELSE
    SET @Result = 'N'

  IF @TableName LIKE '%HIST'
    SET @Result = 'N'
 
 RETURN @Result;
END
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create sequence dbo.ETL_DATA_SOURCE_TRACE_ID_SEQ
PRINT N'Create sequence dbo.ETL_DATA_SOURCE_TRACE_ID_SEQ'
GO
CREATE SEQUENCE [dbo].[ETL_DATA_SOURCE_TRACE_ID_SEQ]
	AS bigint
	START WITH 1
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	NO CYCLE
	CACHE 50
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create table dbo.PIMS_DATA_SOURCE_TYPE
PRINT N'Create table dbo.PIMS_DATA_SOURCE_TYPE'
GO
CREATE TABLE [dbo].[PIMS_DATA_SOURCE_TYPE]  ( 
	[DATA_SOURCE_TYPE_CODE]     	nvarchar(20) NOT NULL,
	[DESCRIPTION]               	nvarchar(200) NOT NULL,
	[IS_DISABLED]               	bit NOT NULL DEFAULT (CONVERT([bit],(0))),
	[DISPLAY_ORDER]             	int NULL,
	[CONCURRENCY_CONTROL_NUMBER]	bigint NOT NULL DEFAULT ((1)),
	[DB_CREATE_TIMESTAMP]       	datetime NOT NULL DEFAULT (getutcdate()),
	[DB_CREATE_USERID]          	nvarchar(30) NOT NULL DEFAULT (user_name()),
	[DB_LAST_UPDATE_TIMESTAMP]  	datetime NOT NULL DEFAULT (getutcdate()),
	[DB_LAST_UPDATE_USERID]     	nvarchar(30) NOT NULL DEFAULT (user_name()),
	PRIMARY KEY CLUSTERED([DATA_SOURCE_TYPE_CODE])
 ON [PRIMARY])
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'Code val;ue of the source system of the data (PAIMS, LIS, etc.)' , 
	@level0type = N'Schema', @level0name = N'dbo', 
	@level1type = N'Table', @level1name = N'PIMS_DATA_SOURCE_TYPE', 
	@level2type = N'Column', @level2name = N'DATA_SOURCE_TYPE_CODE'
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'Description of the source system of the data (PAIMS, LIS, etc.)' , 
	@level0type = N'Schema', @level0name = N'dbo', 
	@level1type = N'Table', @level1name = N'PIMS_DATA_SOURCE_TYPE', 
	@level2type = N'Column', @level2name = N'DESCRIPTION'
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'Indicates if the code is still in use' , 
	@level0type = N'Schema', @level0name = N'dbo', 
	@level1type = N'Table', @level1name = N'PIMS_DATA_SOURCE_TYPE', 
	@level2type = N'Column', @level2name = N'IS_DISABLED'
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'Defines the default display order of the descriptions' , 
	@level0type = N'Schema', @level0name = N'dbo', 
	@level1type = N'Table', @level1name = N'PIMS_DATA_SOURCE_TYPE', 
	@level2type = N'Column', @level2name = N'DISPLAY_ORDER'
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'Describes the source system of the data (PAIMS, LIS, etc.)' , 
	@level0type = N'Schema', @level0name = N'dbo', 
	@level1type = N'Table', @level1name = N'PIMS_DATA_SOURCE_TYPE'
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create table etl.ETL_DATA_SOURCE_TRACE
PRINT N'Create table etl.ETL_DATA_SOURCE_TRACE'
GO
CREATE TABLE [etl].[ETL_DATA_SOURCE_TRACE]  ( 
	[DATA_SOURCE_TRACE_ID]      	bigint NOT NULL DEFAULT (NEXT VALUE FOR [ETL_DATA_SOURCE_TRACE_ID_SEQ]),
	[DATA_SOURCE_TYPE_CODE]     	nvarchar(20) NOT NULL,
	[DEST_TABLE_NAME]           	nvarchar(100) NOT NULL,
	[DEST_COLUMN_NAME]          	nvarchar(100) NOT NULL,
	[DEST_COLUMN_VALUE]         	nvarchar(500) NOT NULL,
	[SRC_TABLE_NAME]            	nvarchar(100) NOT NULL,
	[SRC_COLUMN_NAME]           	nvarchar(100) NOT NULL,
	[SRC_COLUMN_VALUE]          	nvarchar(500) NOT NULL,
	[ErrorCode]                 	int NULL,
	[ErrorColumn]               	int NULL,
	[CONCURRENCY_CONTROL_NUMBER]	bigint NOT NULL DEFAULT ((1)),
	[DB_CREATE_TIMESTAMP]       	datetime NOT NULL DEFAULT (getutcdate()),
	[DB_CREATE_USERID]          	nvarchar(30) NOT NULL DEFAULT (user_name()),
	[DB_LAST_UPDATE_TIMESTAMP]  	datetime NOT NULL DEFAULT (getutcdate()),
	[DB_LAST_UPDATE_USERID]     	nvarchar(30) NOT NULL DEFAULT (user_name()),
	PRIMARY KEY CLUSTERED([DATA_SOURCE_TRACE_ID])
 ON [PRIMARY])
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'The PIMS destination table name' , 
	@level0type = N'Schema', @level0name = N'etl', 
	@level1type = N'Table', @level1name = N'ETL_DATA_SOURCE_TRACE', 
	@level2type = N'Column', @level2name = N'DEST_TABLE_NAME'
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'The PIMS destination column name' , 
	@level0type = N'Schema', @level0name = N'etl', 
	@level1type = N'Table', @level1name = N'ETL_DATA_SOURCE_TRACE', 
	@level2type = N'Column', @level2name = N'DEST_COLUMN_NAME'
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'The PIMS destination column value' , 
	@level0type = N'Schema', @level0name = N'etl', 
	@level1type = N'Table', @level1name = N'ETL_DATA_SOURCE_TRACE', 
	@level2type = N'Column', @level2name = N'DEST_COLUMN_VALUE'
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'The data source table name' , 
	@level0type = N'Schema', @level0name = N'etl', 
	@level1type = N'Table', @level1name = N'ETL_DATA_SOURCE_TRACE', 
	@level2type = N'Column', @level2name = N'SRC_TABLE_NAME'
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'The data source column name' , 
	@level0type = N'Schema', @level0name = N'etl', 
	@level1type = N'Table', @level1name = N'ETL_DATA_SOURCE_TRACE', 
	@level2type = N'Column', @level2name = N'SRC_COLUMN_NAME'
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'The data source column value' , 
	@level0type = N'Schema', @level0name = N'etl', 
	@level1type = N'Table', @level1name = N'ETL_DATA_SOURCE_TRACE', 
	@level2type = N'Column', @level2name = N'SRC_COLUMN_VALUE'
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'Persistent table to trace the source of ETL data to assist in data matching.' , 
	@level0type = N'Schema', @level0name = N'etl', 
	@level1type = N'Table', @level1name = N'ETL_DATA_SOURCE_TRACE'
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create procedure dbo.pims_error_handling
PRINT N'Create procedure dbo.pims_error_handling'
GO
-- ............................................................................................


-- --------------------------------------------------------------------------------------------
-- Create procedure pims_error_handling 
-- --------------------------------------------------------------------------------------------
CREATE PROCEDURE [dbo].[pims_error_handling] AS 
  begin
    DECLARE @errmsg   nvarchar(2048),
      @severity tinyint,
      @state    tinyint,
      @errno    int,
      @proc     sysname,
      @lineno   int
           
    SELECT @errmsg = error_message(), @severity = error_severity(),
      @state  = error_state(), @errno = error_number(),
      @proc   = error_procedure(), @lineno = error_line()

    IF @errmsg NOT LIKE '***%'
      BEGIN
        SELECT @errmsg = '*** ' + coalesce(quotename(@proc), '<dynamic SQL>') + 
          ', Line ' + ltrim(str(@lineno)) + '. Errno ' + 
          ltrim(str(@errno)) + ': ' + @errmsg
      END

    RAISERROR('%s', @severity, @state, @errmsg)
  end
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Alter table dbo.PIMS_LEASE
PRINT N'Alter table dbo.PIMS_LEASE'
GO
ALTER TABLE [dbo].[PIMS_LEASE]
	ADD [RETURN_NOTES] nvarchar(4000) NULL
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'Notes accompanying lease' , 
	@level0type = N'Schema', @level0name = N'dbo', 
	@level1type = N'Table', @level1name = N'PIMS_LEASE', 
	@level2type = N'Column', @level2name = N'RETURN_NOTES'
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Alter table dbo.PIMS_SECURITY_DEPOSIT_RETURN
PRINT N'Alter table dbo.PIMS_SECURITY_DEPOSIT_RETURN'
GO
ALTER TABLE [dbo].[PIMS_SECURITY_DEPOSIT_RETURN] ALTER COLUMN [PAYEE_ADDRESS] nvarchar(500) NULL
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO
ALTER TABLE [dbo].[PIMS_SECURITY_DEPOSIT_RETURN]
	DROP COLUMN [TERMINATION_NOTE]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Alter table dbo.PIMS_SECURITY_DEPOSIT
PRINT N'Alter table dbo.PIMS_SECURITY_DEPOSIT'
GO
EXEC dbo.sp_rename N'dbo.PIMS_SECURITY_DEPOSIT.TOTAL_AMOUNT' , N'OTHER_DEP_HOLDER_TYPE_DESC', 'COLUMN'
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO
ALTER TABLE [dbo].[PIMS_SECURITY_DEPOSIT] ALTER COLUMN [OTHER_DEP_HOLDER_TYPE_DESC] nvarchar(100) NULL
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Alter table dbo.PIMS_LEASE_HIST
PRINT N'Alter table dbo.PIMS_LEASE_HIST'
GO
ALTER TABLE [dbo].[PIMS_LEASE_HIST]
	ADD [RETURN_NOTES] nvarchar(4000) NULL
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Alter table dbo.PIMS_SECURITY_DEPOSIT_RETURN_HIST
PRINT N'Alter table dbo.PIMS_SECURITY_DEPOSIT_RETURN_HIST'
GO
ALTER TABLE [dbo].[PIMS_SECURITY_DEPOSIT_RETURN_HIST] ALTER COLUMN [PAYEE_ADDRESS] nvarchar(500) NULL
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO
ALTER TABLE [dbo].[PIMS_SECURITY_DEPOSIT_RETURN_HIST]
	DROP COLUMN [TERMINATION_NOTE]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Alter table dbo.PIMS_SECURITY_DEPOSIT_HIST
PRINT N'Alter table dbo.PIMS_SECURITY_DEPOSIT_HIST'
GO
EXEC dbo.sp_rename N'dbo.PIMS_SECURITY_DEPOSIT_HIST.TOTAL_AMOUNT' , N'OTHER_DEP_HOLDER_TYPE_DESC', 'COLUMN'
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO
ALTER TABLE [dbo].[PIMS_SECURITY_DEPOSIT_HIST] ALTER COLUMN [OTHER_DEP_HOLDER_TYPE_DESC] nvarchar(100) NULL
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

DROP VIEW [dbo].[PIMS_CONTACT_MGR_VW]
GO
-- Create view dbo.PIMS_CONTACT_MGR_VW
PRINT N'Create view dbo.PIMS_CONTACT_MGR_VW'
GO
CREATE VIEW [dbo].[PIMS_CONTACT_MGR_VW] AS
  SELECT CONCAT('P', PER.PERSON_ID) AS ID
       , PER.PERSON_ID
       , NULL                   AS ORGANIZATION_ID
       , PER.IS_DISABLED
       , TRIM(CONCAT_WS(' ', PER.FIRST_NAME, PER.MIDDLE_NAMES, PER.SURNAME)) AS SUMMARY
       , PER.SURNAME
       , PER.FIRST_NAME
       , PER.MIDDLE_NAMES
       , NULL                    AS ORGANIZATION_NAME
       , PAD.ADDRESS_ID                              
       , ADR.STREET_ADDRESS_1    AS MAILING_ADDRESS
       , ADR.MUNICIPALITY_NAME
       , PRV.PROVINCE_STATE_CODE AS PROVINCE_STATE 
  FROM   PIMS_PERSON         PER                                           LEFT JOIN
         PIMS_PERSON_ADDRESS PAD ON PAD.PERSON_ID         = PER.PERSON_ID  LEFT JOIN
         PIMS_ADDRESS        ADR ON ADR.ADDRESS_ID        = PAD.ADDRESS_ID LEFT JOIN 
         PIMS_PROVINCE_STATE PRV ON PRV.PROVINCE_STATE_ID = ADR.PROVINCE_STATE_ID
  UNION
  SELECT CONCAT('O', ORG.ORGANIZATION_ID) AS ID
       , NULL                        AS PERSON_ID
       , ORG.ORGANIZATION_ID
       , ORG.IS_DISABLED
       , ORG.ORGANIZATION_NAME       AS SUMMARY
       , NULL                        AS SURNAME
       , NULL                        AS FIRST_NAME
       , NULL                        AS MIDDLE_NAMES
       , ORG.ORGANIZATION_NAME
       , OAD.ADDRESS_ID
       , ADR.STREET_ADDRESS_1        AS MAILING_ADDRESS
       , ADR.MUNICIPALITY_NAME
       , PRV.PROVINCE_STATE_CODE     AS PROVINCE_STATE 
  FROM   PIMS_ORGANIZATION         ORG                                              LEFT JOIN 
         PIMS_ORGANIZATION_ADDRESS OAD ON OAD.ORGANIZATION_ID = ORG.ORGANIZATION_ID LEFT JOIN
         PIMS_ADDRESS              ADR ON ADR.ADDRESS_ID      = OAD.ADDRESS_ID      LEFT JOIN 
         PIMS_PROVINCE_STATE       PRV ON PRV.PROVINCE_STATE_ID = ADR.PROVINCE_STATE_ID
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create index etl.SRCTRC_DATA_SOURCE_TYPE_CODE_IDX
PRINT N'Create index etl.SRCTRC_DATA_SOURCE_TYPE_CODE_IDX'
GO
CREATE NONCLUSTERED INDEX [SRCTRC_DATA_SOURCE_TYPE_CODE_IDX]
	ON [etl].[ETL_DATA_SOURCE_TRACE]([DATA_SOURCE_TYPE_CODE])
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create unique index etl.SRCTRC_DATA_SOURCE_UK
PRINT N'Create unique index etl.SRCTRC_DATA_SOURCE_UK'
GO
CREATE UNIQUE NONCLUSTERED INDEX [SRCTRC_DATA_SOURCE_UK]
	ON [etl].[ETL_DATA_SOURCE_TRACE]([DATA_SOURCE_TYPE_CODE], [DEST_TABLE_NAME], [DEST_COLUMN_NAME], [DEST_COLUMN_VALUE])
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create foreign key constraint PIM_PIDSRT_PIM_SRCTRC_FK
PRINT N'Create foreign key constraint PIM_PIDSRT_PIM_SRCTRC_FK'
GO
ALTER TABLE [etl].[ETL_DATA_SOURCE_TRACE]
	ADD FOREIGN KEY([DATA_SOURCE_TYPE_CODE])
	REFERENCES [dbo].[PIMS_DATA_SOURCE_TYPE]([DATA_SOURCE_TYPE_CODE])
	ON DELETE NO ACTION 
	ON UPDATE NO ACTION 
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger dbo.PIMS_LEASE_I_S_I_TR
PRINT N'Create trigger dbo.PIMS_LEASE_I_S_I_TR'
GO
CREATE TRIGGER [dbo].[PIMS_LEASE_I_S_I_TR] ON PIMS_LEASE INSTEAD OF INSERT AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM inserted) 
    RETURN;

  
  insert into PIMS_LEASE ("LEASE_ID",
      "MOTI_NAME_ID",
      "LEASE_PAY_RVBL_TYPE_CODE",
      "LEASE_LICENSE_TYPE_CODE",
      "LEASE_CATEGORY_TYPE_CODE",
      "LEASE_PURPOSE_TYPE_CODE",
      "LEASE_PROGRAM_TYPE_CODE",
      "LEASE_INITIATOR_TYPE_CODE",
      "LEASE_RESPONSIBILITY_TYPE_CODE",
      "LEASE_PMT_FREQ_TYPE_CODE",
      "LEASE_PURPOSE_OTHER_DESC",
      "L_FILE_NO",
      "TFA_FILE_NO",
      "PS_FILE_NO",
      "LEASE_DESCRIPTION",
      "LEASE_NOTES",
      "RETURN_NOTES",
      "ORIG_START_DATE",
      "ORIG_EXPIRY_DATE",
      "IS_ORIG_EXPIRY_REQUIRED",
      "INCLUDED_RENEWALS",
      "RENEWAL_COUNT",
      "RENEWAL_TERM_MONTHS",
      "LEASE_AMOUNT",
      "RESPONSIBILITY_EFFECTIVE_DATE",
      "INSPECTION_DATE",
      "INSPECTION_NOTES",
      "IS_SUBJECT_TO_RTA",
      "IS_COMM_BLDG",
      "IS_OTHER_IMPROVEMENT",
      "IS_EXPIRED",
      "HAS_PHYSICAL_FILE",
      "HAS_DIGITAL_FILE",
      "HAS_PHYSICIAL_LICENSE",
      "HAS_DIGITAL_LICENSE",
      "CONCURRENCY_CONTROL_NUMBER",
      "APP_CREATE_TIMESTAMP",
      "APP_CREATE_USERID",
      "APP_CREATE_USER_GUID",
      "APP_CREATE_USER_DIRECTORY",
      "APP_LAST_UPDATE_TIMESTAMP",
      "APP_LAST_UPDATE_USERID",
      "APP_LAST_UPDATE_USER_GUID",
      "APP_LAST_UPDATE_USER_DIRECTORY")
    select "LEASE_ID",
      "MOTI_NAME_ID",
      "LEASE_PAY_RVBL_TYPE_CODE",
      "LEASE_LICENSE_TYPE_CODE",
      "LEASE_CATEGORY_TYPE_CODE",
      "LEASE_PURPOSE_TYPE_CODE",
      "LEASE_PROGRAM_TYPE_CODE",
      "LEASE_INITIATOR_TYPE_CODE",
      "LEASE_RESPONSIBILITY_TYPE_CODE",
      "LEASE_PMT_FREQ_TYPE_CODE",
      "LEASE_PURPOSE_OTHER_DESC",
      "L_FILE_NO",
      "TFA_FILE_NO",
      "PS_FILE_NO",
      "LEASE_DESCRIPTION",
      "LEASE_NOTES",
      "RETURN_NOTES",
      "ORIG_START_DATE",
      "ORIG_EXPIRY_DATE",
      "IS_ORIG_EXPIRY_REQUIRED",
      "INCLUDED_RENEWALS",
      "RENEWAL_COUNT",
      "RENEWAL_TERM_MONTHS",
      "LEASE_AMOUNT",
      "RESPONSIBILITY_EFFECTIVE_DATE",
      "INSPECTION_DATE",
      "INSPECTION_NOTES",
      "IS_SUBJECT_TO_RTA",
      "IS_COMM_BLDG",
      "IS_OTHER_IMPROVEMENT",
      "IS_EXPIRED",
      "HAS_PHYSICAL_FILE",
      "HAS_DIGITAL_FILE",
      "HAS_PHYSICIAL_LICENSE",
      "HAS_DIGITAL_LICENSE",
      "CONCURRENCY_CONTROL_NUMBER",
      "APP_CREATE_TIMESTAMP",
      "APP_CREATE_USERID",
      "APP_CREATE_USER_GUID",
      "APP_CREATE_USER_DIRECTORY",
      "APP_LAST_UPDATE_TIMESTAMP",
      "APP_LAST_UPDATE_USERID",
      "APP_LAST_UPDATE_USER_GUID",
      "APP_LAST_UPDATE_USER_DIRECTORY"
    from inserted;

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC pims_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger dbo.PIMS_PROJCT_A_S_IUD_TR
PRINT N'Create trigger dbo.PIMS_PROJCT_A_S_IUD_TR'
GO
CREATE TRIGGER [dbo].[PIMS_PROJCT_A_S_IUD_TR] ON PIMS_PROJECT FOR INSERT, UPDATE, DELETE AS
SET NOCOUNT ON
BEGIN TRY
DECLARE @curr_date datetime;
SET @curr_date = getutcdate();
  IF NOT EXISTS(SELECT * FROM inserted) AND NOT EXISTS(SELECT * FROM deleted) 
    RETURN;

  -- historical
  IF EXISTS(SELECT * FROM deleted)
    update PIMS_PROJECT_HIST set END_DATE_HIST = @curr_date where PROJECT_ID in (select PROJECT_ID from deleted) and END_DATE_HIST is null;
  
  IF EXISTS(SELECT * FROM inserted)
    insert into PIMS_PROJECT_HIST ([PROJECT_ID], [PROJECT_TYPE_CODE], [PROJECT_STATUS_TYPE_CODE], [PROJECT_RISK_TYPE_CODE], [PROJECT_TIER_TYPE_CODE], [CONCURRENCY_CONTROL_NUMBER], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [DB_CREATE_TIMESTAMP], [DB_CREATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], _PROJECT_HIST_ID, END_DATE_HIST, EFFECTIVE_DATE_HIST)
      select [PROJECT_ID], [PROJECT_TYPE_CODE], [PROJECT_STATUS_TYPE_CODE], [PROJECT_RISK_TYPE_CODE], [PROJECT_TIER_TYPE_CODE], [CONCURRENCY_CONTROL_NUMBER], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [DB_CREATE_TIMESTAMP], [DB_CREATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], (next value for [dbo].[PIMS_PROJECT_H_ID_SEQ]) as [_PROJECT_HIST_ID], null as [END_DATE_HIST], @curr_date as [EFFECTIVE_DATE_HIST] from inserted;

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC pims_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger dbo.PIMS_SDRTRN_I_S_I_TR
PRINT N'Create trigger dbo.PIMS_SDRTRN_I_S_I_TR'
GO
CREATE TRIGGER [dbo].[PIMS_SDRTRN_I_S_I_TR] ON PIMS_SECURITY_DEPOSIT_RETURN INSTEAD OF INSERT AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM inserted) 
    RETURN;

  
  insert into PIMS_SECURITY_DEPOSIT_RETURN ("SECURITY_DEPOSIT_RETURN_ID",
      "LEASE_ID",
      "SECURITY_DEPOSIT_TYPE_CODE",
      "TERMINATION_DATE",
      "DEPOSIT_TOTAL",
      "CLAIMS_AGAINST",
      "RETURN_AMOUNT",
      "RETURN_DATE",
      "CHEQUE_NUMBER",
      "PAYEE_NAME",
      "PAYEE_ADDRESS",
      "CONCURRENCY_CONTROL_NUMBER",
      "APP_CREATE_TIMESTAMP",
      "APP_CREATE_USERID",
      "APP_CREATE_USER_GUID",
      "APP_CREATE_USER_DIRECTORY",
      "APP_LAST_UPDATE_TIMESTAMP",
      "APP_LAST_UPDATE_USERID",
      "APP_LAST_UPDATE_USER_GUID",
      "APP_LAST_UPDATE_USER_DIRECTORY")
    select "SECURITY_DEPOSIT_RETURN_ID",
      "LEASE_ID",
      "SECURITY_DEPOSIT_TYPE_CODE",
      "TERMINATION_DATE",
      "DEPOSIT_TOTAL",
      "CLAIMS_AGAINST",
      "RETURN_AMOUNT",
      "RETURN_DATE",
      "CHEQUE_NUMBER",
      "PAYEE_NAME",
      "PAYEE_ADDRESS",
      "CONCURRENCY_CONTROL_NUMBER",
      "APP_CREATE_TIMESTAMP",
      "APP_CREATE_USERID",
      "APP_CREATE_USER_GUID",
      "APP_CREATE_USER_DIRECTORY",
      "APP_LAST_UPDATE_TIMESTAMP",
      "APP_LAST_UPDATE_USERID",
      "APP_LAST_UPDATE_USER_GUID",
      "APP_LAST_UPDATE_USER_DIRECTORY"
    from inserted;

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC pims_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger dbo.PIMS_LEASE_I_S_U_TR
PRINT N'Create trigger dbo.PIMS_LEASE_I_S_U_TR'
GO
CREATE TRIGGER [dbo].[PIMS_LEASE_I_S_U_TR] ON PIMS_LEASE INSTEAD OF UPDATE AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM deleted) 
    RETURN;

  -- validate concurrency control
  if exists (select 1 from inserted, deleted where inserted.CONCURRENCY_CONTROL_NUMBER != deleted.CONCURRENCY_CONTROL_NUMBER+1 AND inserted.LEASE_ID = deleted.LEASE_ID)
    raiserror('CONCURRENCY FAILURE.',16,1)


  -- update statement
  update PIMS_LEASE
    set "LEASE_ID" = inserted."LEASE_ID",
      "MOTI_NAME_ID" = inserted."MOTI_NAME_ID",
      "LEASE_PAY_RVBL_TYPE_CODE" = inserted."LEASE_PAY_RVBL_TYPE_CODE",
      "LEASE_LICENSE_TYPE_CODE" = inserted."LEASE_LICENSE_TYPE_CODE",
      "LEASE_CATEGORY_TYPE_CODE" = inserted."LEASE_CATEGORY_TYPE_CODE",
      "LEASE_PURPOSE_TYPE_CODE" = inserted."LEASE_PURPOSE_TYPE_CODE",
      "LEASE_PROGRAM_TYPE_CODE" = inserted."LEASE_PROGRAM_TYPE_CODE",
      "LEASE_INITIATOR_TYPE_CODE" = inserted."LEASE_INITIATOR_TYPE_CODE",
      "LEASE_RESPONSIBILITY_TYPE_CODE" = inserted."LEASE_RESPONSIBILITY_TYPE_CODE",
      "LEASE_PMT_FREQ_TYPE_CODE" = inserted."LEASE_PMT_FREQ_TYPE_CODE",
      "LEASE_PURPOSE_OTHER_DESC" = inserted."LEASE_PURPOSE_OTHER_DESC",
      "L_FILE_NO" = inserted."L_FILE_NO",
      "TFA_FILE_NO" = inserted."TFA_FILE_NO",
      "PS_FILE_NO" = inserted."PS_FILE_NO",
      "LEASE_DESCRIPTION" = inserted."LEASE_DESCRIPTION",
      "LEASE_NOTES" = inserted."LEASE_NOTES",
      "RETURN_NOTES" = inserted."RETURN_NOTES",
      "ORIG_START_DATE" = inserted."ORIG_START_DATE",
      "ORIG_EXPIRY_DATE" = inserted."ORIG_EXPIRY_DATE",
      "IS_ORIG_EXPIRY_REQUIRED" = inserted."IS_ORIG_EXPIRY_REQUIRED",
      "INCLUDED_RENEWALS" = inserted."INCLUDED_RENEWALS",
      "RENEWAL_COUNT" = inserted."RENEWAL_COUNT",
      "RENEWAL_TERM_MONTHS" = inserted."RENEWAL_TERM_MONTHS",
      "LEASE_AMOUNT" = inserted."LEASE_AMOUNT",
      "RESPONSIBILITY_EFFECTIVE_DATE" = inserted."RESPONSIBILITY_EFFECTIVE_DATE",
      "INSPECTION_DATE" = inserted."INSPECTION_DATE",
      "INSPECTION_NOTES" = inserted."INSPECTION_NOTES",
      "IS_SUBJECT_TO_RTA" = inserted."IS_SUBJECT_TO_RTA",
      "IS_COMM_BLDG" = inserted."IS_COMM_BLDG",
      "IS_OTHER_IMPROVEMENT" = inserted."IS_OTHER_IMPROVEMENT",
      "IS_EXPIRED" = inserted."IS_EXPIRED",
      "HAS_PHYSICAL_FILE" = inserted."HAS_PHYSICAL_FILE",
      "HAS_DIGITAL_FILE" = inserted."HAS_DIGITAL_FILE",
      "HAS_PHYSICIAL_LICENSE" = inserted."HAS_PHYSICIAL_LICENSE",
      "HAS_DIGITAL_LICENSE" = inserted."HAS_DIGITAL_LICENSE",
      "CONCURRENCY_CONTROL_NUMBER" = inserted."CONCURRENCY_CONTROL_NUMBER",
      "APP_LAST_UPDATE_TIMESTAMP" = inserted."APP_LAST_UPDATE_TIMESTAMP",
      "APP_LAST_UPDATE_USERID" = inserted."APP_LAST_UPDATE_USERID",
      "APP_LAST_UPDATE_USER_GUID" = inserted."APP_LAST_UPDATE_USER_GUID",
      "APP_LAST_UPDATE_USER_DIRECTORY" = inserted."APP_LAST_UPDATE_USER_DIRECTORY"
    , DB_LAST_UPDATE_TIMESTAMP = getutcdate()
    , DB_LAST_UPDATE_USERID = user_name()
    from PIMS_LEASE
    inner join inserted
    on (PIMS_LEASE.LEASE_ID = inserted.LEASE_ID);

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC pims_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger dbo.PIMS_SDRTRN_I_S_U_TR
PRINT N'Create trigger dbo.PIMS_SDRTRN_I_S_U_TR'
GO
CREATE TRIGGER [dbo].[PIMS_SDRTRN_I_S_U_TR] ON PIMS_SECURITY_DEPOSIT_RETURN INSTEAD OF UPDATE AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM deleted) 
    RETURN;

  -- validate concurrency control
  if exists (select 1 from inserted, deleted where inserted.CONCURRENCY_CONTROL_NUMBER != deleted.CONCURRENCY_CONTROL_NUMBER+1 AND inserted.SECURITY_DEPOSIT_RETURN_ID = deleted.SECURITY_DEPOSIT_RETURN_ID)
    raiserror('CONCURRENCY FAILURE.',16,1)


  -- update statement
  update PIMS_SECURITY_DEPOSIT_RETURN
    set "SECURITY_DEPOSIT_RETURN_ID" = inserted."SECURITY_DEPOSIT_RETURN_ID",
      "LEASE_ID" = inserted."LEASE_ID",
      "SECURITY_DEPOSIT_TYPE_CODE" = inserted."SECURITY_DEPOSIT_TYPE_CODE",
      "TERMINATION_DATE" = inserted."TERMINATION_DATE",
      "DEPOSIT_TOTAL" = inserted."DEPOSIT_TOTAL",
      "CLAIMS_AGAINST" = inserted."CLAIMS_AGAINST",
      "RETURN_AMOUNT" = inserted."RETURN_AMOUNT",
      "RETURN_DATE" = inserted."RETURN_DATE",
      "CHEQUE_NUMBER" = inserted."CHEQUE_NUMBER",
      "PAYEE_NAME" = inserted."PAYEE_NAME",
      "PAYEE_ADDRESS" = inserted."PAYEE_ADDRESS",
      "CONCURRENCY_CONTROL_NUMBER" = inserted."CONCURRENCY_CONTROL_NUMBER",
      "APP_LAST_UPDATE_TIMESTAMP" = inserted."APP_LAST_UPDATE_TIMESTAMP",
      "APP_LAST_UPDATE_USERID" = inserted."APP_LAST_UPDATE_USERID",
      "APP_LAST_UPDATE_USER_GUID" = inserted."APP_LAST_UPDATE_USER_GUID",
      "APP_LAST_UPDATE_USER_DIRECTORY" = inserted."APP_LAST_UPDATE_USER_DIRECTORY"
    , DB_LAST_UPDATE_TIMESTAMP = getutcdate()
    , DB_LAST_UPDATE_USERID = user_name()
    from PIMS_SECURITY_DEPOSIT_RETURN
    inner join inserted
    on (PIMS_SECURITY_DEPOSIT_RETURN.SECURITY_DEPOSIT_RETURN_ID = inserted.SECURITY_DEPOSIT_RETURN_ID);

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC pims_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger dbo.PIMS_PIDSRT_I_S_I_TR
PRINT N'Create trigger dbo.PIMS_PIDSRT_I_S_I_TR'
GO
CREATE TRIGGER [dbo].[PIMS_PIDSRT_I_S_I_TR] ON PIMS_DATA_SOURCE_TYPE INSTEAD OF INSERT AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM inserted) 
    RETURN;

  
  insert into PIMS_DATA_SOURCE_TYPE ("DATA_SOURCE_TYPE_CODE",
      "DESCRIPTION",
      "IS_DISABLED",
      "DISPLAY_ORDER",
      "CONCURRENCY_CONTROL_NUMBER")
    select "DATA_SOURCE_TYPE_CODE",
      "DESCRIPTION",
      "IS_DISABLED",
      "DISPLAY_ORDER",
      "CONCURRENCY_CONTROL_NUMBER"
    from inserted;

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC pims_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger dbo.PIMS_PIDSRT_I_S_U_TR
PRINT N'Create trigger dbo.PIMS_PIDSRT_I_S_U_TR'
GO
CREATE TRIGGER [dbo].[PIMS_PIDSRT_I_S_U_TR] ON PIMS_DATA_SOURCE_TYPE INSTEAD OF UPDATE AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM deleted) 
    RETURN;

  -- validate concurrency control
  if exists (select 1 from inserted, deleted where inserted.CONCURRENCY_CONTROL_NUMBER != deleted.CONCURRENCY_CONTROL_NUMBER+1 AND inserted.DATA_SOURCE_TYPE_CODE = deleted.DATA_SOURCE_TYPE_CODE)
    raiserror('CONCURRENCY FAILURE.',16,1)


  -- update statement
  update PIMS_DATA_SOURCE_TYPE
    set "DATA_SOURCE_TYPE_CODE" = inserted."DATA_SOURCE_TYPE_CODE",
      "DESCRIPTION" = inserted."DESCRIPTION",
      "IS_DISABLED" = inserted."IS_DISABLED",
      "DISPLAY_ORDER" = inserted."DISPLAY_ORDER",
      "CONCURRENCY_CONTROL_NUMBER" = inserted."CONCURRENCY_CONTROL_NUMBER"
    , DB_LAST_UPDATE_TIMESTAMP = getutcdate()
    , DB_LAST_UPDATE_USERID = user_name()
    from PIMS_DATA_SOURCE_TYPE
    inner join inserted
    on (PIMS_DATA_SOURCE_TYPE.DATA_SOURCE_TYPE_CODE = inserted.DATA_SOURCE_TYPE_CODE);

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC pims_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger dbo.PIMS_SECDEP_I_S_U_TR
PRINT N'Create trigger dbo.PIMS_SECDEP_I_S_U_TR'
GO
CREATE TRIGGER [dbo].[PIMS_SECDEP_I_S_U_TR] ON PIMS_SECURITY_DEPOSIT INSTEAD OF UPDATE AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM deleted) 
    RETURN;

  -- validate concurrency control
  if exists (select 1 from inserted, deleted where inserted.CONCURRENCY_CONTROL_NUMBER != deleted.CONCURRENCY_CONTROL_NUMBER+1 AND inserted.SECURITY_DEPOSIT_ID = deleted.SECURITY_DEPOSIT_ID)
    raiserror('CONCURRENCY FAILURE.',16,1)


  -- update statement
  update PIMS_SECURITY_DEPOSIT
    set "SECURITY_DEPOSIT_ID" = inserted."SECURITY_DEPOSIT_ID",
      "LEASE_ID" = inserted."LEASE_ID",
      "SEC_DEP_HOLDER_TYPE_CODE" = inserted."SEC_DEP_HOLDER_TYPE_CODE",
      "SECURITY_DEPOSIT_TYPE_CODE" = inserted."SECURITY_DEPOSIT_TYPE_CODE",
      "OTHER_DEP_HOLDER_TYPE_DESC" = inserted."OTHER_DEP_HOLDER_TYPE_DESC",
      "DESCRIPTION" = inserted."DESCRIPTION",
      "AMOUNT_PAID" = inserted."AMOUNT_PAID",
      "DEPOSIT_DATE" = inserted."DEPOSIT_DATE",
      "ANNUAL_INTEREST_RATE" = inserted."ANNUAL_INTEREST_RATE",
      "CONCURRENCY_CONTROL_NUMBER" = inserted."CONCURRENCY_CONTROL_NUMBER",
      "APP_LAST_UPDATE_TIMESTAMP" = inserted."APP_LAST_UPDATE_TIMESTAMP",
      "APP_LAST_UPDATE_USERID" = inserted."APP_LAST_UPDATE_USERID",
      "APP_LAST_UPDATE_USER_GUID" = inserted."APP_LAST_UPDATE_USER_GUID",
      "APP_LAST_UPDATE_USER_DIRECTORY" = inserted."APP_LAST_UPDATE_USER_DIRECTORY"
    , DB_LAST_UPDATE_TIMESTAMP = getutcdate()
    , DB_LAST_UPDATE_USERID = user_name()
    from PIMS_SECURITY_DEPOSIT
    inner join inserted
    on (PIMS_SECURITY_DEPOSIT.SECURITY_DEPOSIT_ID = inserted.SECURITY_DEPOSIT_ID);

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC pims_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger dbo.PIMS_LEASE_A_S_IUD_TR
PRINT N'Create trigger dbo.PIMS_LEASE_A_S_IUD_TR'
GO
CREATE TRIGGER [dbo].[PIMS_LEASE_A_S_IUD_TR] ON PIMS_LEASE FOR INSERT, UPDATE, DELETE AS
SET NOCOUNT ON
BEGIN TRY
DECLARE @curr_date datetime;
SET @curr_date = getutcdate();
  IF NOT EXISTS(SELECT * FROM inserted) AND NOT EXISTS(SELECT * FROM deleted) 
    RETURN;

  -- historical
  IF EXISTS(SELECT * FROM deleted)
    update PIMS_LEASE_HIST set END_DATE_HIST = @curr_date where LEASE_ID in (select LEASE_ID from deleted) and END_DATE_HIST is null;
  
  IF EXISTS(SELECT * FROM inserted)
    insert into PIMS_LEASE_HIST ([LEASE_ID], [MOTI_NAME_ID], [LEASE_PAY_RVBL_TYPE_CODE], [LEASE_LICENSE_TYPE_CODE], [LEASE_CATEGORY_TYPE_CODE], [LEASE_PURPOSE_TYPE_CODE], [LEASE_PROGRAM_TYPE_CODE], [LEASE_INITIATOR_TYPE_CODE], [LEASE_RESPONSIBILITY_TYPE_CODE], [LEASE_PMT_FREQ_TYPE_CODE], [LEASE_PURPOSE_OTHER_DESC], [L_FILE_NO], [TFA_FILE_NO], [PS_FILE_NO], [LEASE_DESCRIPTION], [LEASE_NOTES], [RETURN_NOTES], [ORIG_START_DATE], [ORIG_EXPIRY_DATE], [IS_ORIG_EXPIRY_REQUIRED], [INCLUDED_RENEWALS], [RENEWAL_COUNT], [RENEWAL_TERM_MONTHS], [LEASE_AMOUNT], [RESPONSIBILITY_EFFECTIVE_DATE], [INSPECTION_DATE], [INSPECTION_NOTES], [IS_SUBJECT_TO_RTA], [IS_COMM_BLDG], [IS_OTHER_IMPROVEMENT], [IS_EXPIRED], [HAS_PHYSICAL_FILE], [HAS_DIGITAL_FILE], [HAS_PHYSICIAL_LICENSE], [HAS_DIGITAL_LICENSE], [CONCURRENCY_CONTROL_NUMBER], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [DB_CREATE_TIMESTAMP], [DB_CREATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], _LEASE_HIST_ID, END_DATE_HIST, EFFECTIVE_DATE_HIST)
      select [LEASE_ID], [MOTI_NAME_ID], [LEASE_PAY_RVBL_TYPE_CODE], [LEASE_LICENSE_TYPE_CODE], [LEASE_CATEGORY_TYPE_CODE], [LEASE_PURPOSE_TYPE_CODE], [LEASE_PROGRAM_TYPE_CODE], [LEASE_INITIATOR_TYPE_CODE], [LEASE_RESPONSIBILITY_TYPE_CODE], [LEASE_PMT_FREQ_TYPE_CODE], [LEASE_PURPOSE_OTHER_DESC], [L_FILE_NO], [TFA_FILE_NO], [PS_FILE_NO], [LEASE_DESCRIPTION], [LEASE_NOTES], [RETURN_NOTES], [ORIG_START_DATE], [ORIG_EXPIRY_DATE], [IS_ORIG_EXPIRY_REQUIRED], [INCLUDED_RENEWALS], [RENEWAL_COUNT], [RENEWAL_TERM_MONTHS], [LEASE_AMOUNT], [RESPONSIBILITY_EFFECTIVE_DATE], [INSPECTION_DATE], [INSPECTION_NOTES], [IS_SUBJECT_TO_RTA], [IS_COMM_BLDG], [IS_OTHER_IMPROVEMENT], [IS_EXPIRED], [HAS_PHYSICAL_FILE], [HAS_DIGITAL_FILE], [HAS_PHYSICIAL_LICENSE], [HAS_DIGITAL_LICENSE], [CONCURRENCY_CONTROL_NUMBER], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [DB_CREATE_TIMESTAMP], [DB_CREATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], (next value for [dbo].[PIMS_LEASE_H_ID_SEQ]) as [_LEASE_HIST_ID], null as [END_DATE_HIST], @curr_date as [EFFECTIVE_DATE_HIST] from inserted;

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC pims_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger dbo.PIMS_SDRTRN_A_S_IUD_TR
PRINT N'Create trigger dbo.PIMS_SDRTRN_A_S_IUD_TR'
GO
CREATE TRIGGER [dbo].[PIMS_SDRTRN_A_S_IUD_TR] ON PIMS_SECURITY_DEPOSIT_RETURN FOR INSERT, UPDATE, DELETE AS
SET NOCOUNT ON
BEGIN TRY
DECLARE @curr_date datetime;
SET @curr_date = getutcdate();
  IF NOT EXISTS(SELECT * FROM inserted) AND NOT EXISTS(SELECT * FROM deleted) 
    RETURN;

  -- historical
  IF EXISTS(SELECT * FROM deleted)
    update PIMS_SECURITY_DEPOSIT_RETURN_HIST set END_DATE_HIST = @curr_date where SECURITY_DEPOSIT_RETURN_ID in (select SECURITY_DEPOSIT_RETURN_ID from deleted) and END_DATE_HIST is null;
  
  IF EXISTS(SELECT * FROM inserted)
    insert into PIMS_SECURITY_DEPOSIT_RETURN_HIST ([SECURITY_DEPOSIT_RETURN_ID], [LEASE_ID], [SECURITY_DEPOSIT_TYPE_CODE], [TERMINATION_DATE], [DEPOSIT_TOTAL], [CLAIMS_AGAINST], [RETURN_AMOUNT], [RETURN_DATE], [CHEQUE_NUMBER], [PAYEE_NAME], [PAYEE_ADDRESS], [CONCURRENCY_CONTROL_NUMBER], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [DB_CREATE_TIMESTAMP], [DB_CREATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], _SECURITY_DEPOSIT_RETURN_HIST_ID, END_DATE_HIST, EFFECTIVE_DATE_HIST)
      select [SECURITY_DEPOSIT_RETURN_ID], [LEASE_ID], [SECURITY_DEPOSIT_TYPE_CODE], [TERMINATION_DATE], [DEPOSIT_TOTAL], [CLAIMS_AGAINST], [RETURN_AMOUNT], [RETURN_DATE], [CHEQUE_NUMBER], [PAYEE_NAME], [PAYEE_ADDRESS], [CONCURRENCY_CONTROL_NUMBER], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [DB_CREATE_TIMESTAMP], [DB_CREATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], (next value for [dbo].[PIMS_SECURITY_DEPOSIT_RETURN_H_ID_SEQ]) as [_SECURITY_DEPOSIT_RETURN_HIST_ID], null as [END_DATE_HIST], @curr_date as [EFFECTIVE_DATE_HIST] from inserted;

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC pims_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger dbo.PIMS_SECDEP_A_S_IUD_TR
PRINT N'Create trigger dbo.PIMS_SECDEP_A_S_IUD_TR'
GO
CREATE TRIGGER [dbo].[PIMS_SECDEP_A_S_IUD_TR] ON PIMS_SECURITY_DEPOSIT FOR INSERT, UPDATE, DELETE AS
SET NOCOUNT ON
BEGIN TRY
DECLARE @curr_date datetime;
SET @curr_date = getutcdate();
  IF NOT EXISTS(SELECT * FROM inserted) AND NOT EXISTS(SELECT * FROM deleted) 
    RETURN;

  -- historical
  IF EXISTS(SELECT * FROM deleted)
    update PIMS_SECURITY_DEPOSIT_HIST set END_DATE_HIST = @curr_date where SECURITY_DEPOSIT_ID in (select SECURITY_DEPOSIT_ID from deleted) and END_DATE_HIST is null;
  
  IF EXISTS(SELECT * FROM inserted)
    insert into PIMS_SECURITY_DEPOSIT_HIST ([SECURITY_DEPOSIT_ID], [LEASE_ID], [SEC_DEP_HOLDER_TYPE_CODE], [SECURITY_DEPOSIT_TYPE_CODE], [OTHER_DEP_HOLDER_TYPE_DESC], [DESCRIPTION], [AMOUNT_PAID], [DEPOSIT_DATE], [ANNUAL_INTEREST_RATE], [CONCURRENCY_CONTROL_NUMBER], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [DB_CREATE_TIMESTAMP], [DB_CREATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], _SECURITY_DEPOSIT_HIST_ID, END_DATE_HIST, EFFECTIVE_DATE_HIST)
      select [SECURITY_DEPOSIT_ID], [LEASE_ID], [SEC_DEP_HOLDER_TYPE_CODE], [SECURITY_DEPOSIT_TYPE_CODE], [OTHER_DEP_HOLDER_TYPE_DESC], [DESCRIPTION], [AMOUNT_PAID], [DEPOSIT_DATE], [ANNUAL_INTEREST_RATE], [CONCURRENCY_CONTROL_NUMBER], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [DB_CREATE_TIMESTAMP], [DB_CREATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], (next value for [dbo].[PIMS_SECURITY_DEPOSIT_H_ID_SEQ]) as [_SECURITY_DEPOSIT_HIST_ID], null as [END_DATE_HIST], @curr_date as [EFFECTIVE_DATE_HIST] from inserted;

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC pims_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger dbo.PIMS_SECDEP_I_S_I_TR
PRINT N'Create trigger dbo.PIMS_SECDEP_I_S_I_TR'
GO
CREATE TRIGGER [dbo].[PIMS_SECDEP_I_S_I_TR] ON PIMS_SECURITY_DEPOSIT INSTEAD OF INSERT AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM inserted) 
    RETURN;

  
  insert into PIMS_SECURITY_DEPOSIT ("SECURITY_DEPOSIT_ID",
      "LEASE_ID",
      "SEC_DEP_HOLDER_TYPE_CODE",
      "SECURITY_DEPOSIT_TYPE_CODE",
      "OTHER_DEP_HOLDER_TYPE_DESC",
      "DESCRIPTION",
      "AMOUNT_PAID",
      "DEPOSIT_DATE",
      "ANNUAL_INTEREST_RATE",
      "CONCURRENCY_CONTROL_NUMBER",
      "APP_CREATE_TIMESTAMP",
      "APP_CREATE_USERID",
      "APP_CREATE_USER_GUID",
      "APP_CREATE_USER_DIRECTORY",
      "APP_LAST_UPDATE_TIMESTAMP",
      "APP_LAST_UPDATE_USERID",
      "APP_LAST_UPDATE_USER_GUID",
      "APP_LAST_UPDATE_USER_DIRECTORY")
    select "SECURITY_DEPOSIT_ID",
      "LEASE_ID",
      "SEC_DEP_HOLDER_TYPE_CODE",
      "SECURITY_DEPOSIT_TYPE_CODE",
      "OTHER_DEP_HOLDER_TYPE_DESC",
      "DESCRIPTION",
      "AMOUNT_PAID",
      "DEPOSIT_DATE",
      "ANNUAL_INTEREST_RATE",
      "CONCURRENCY_CONTROL_NUMBER",
      "APP_CREATE_TIMESTAMP",
      "APP_CREATE_USERID",
      "APP_CREATE_USER_GUID",
      "APP_CREATE_USER_DIRECTORY",
      "APP_LAST_UPDATE_TIMESTAMP",
      "APP_LAST_UPDATE_USERID",
      "APP_LAST_UPDATE_USER_GUID",
      "APP_LAST_UPDATE_USER_DIRECTORY"
    from inserted;

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC pims_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Drop table dbo.PIMS_PROPERTY_DATA_SOURCE_TYPE
PRINT N'Drop table dbo.PIMS_PROPERTY_DATA_SOURCE_TYPE'
GO
DROP TABLE [dbo].[PIMS_PROPERTY_DATA_SOURCE_TYPE]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

COMMIT TRANSACTION
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO
DECLARE @Success AS BIT
SET @Success = 1
SET NOEXEC OFF
IF (@Success = 1) PRINT 'The database update succeeded'
ELSE BEGIN
   IF @@TRANCOUNT > 0 ROLLBACK TRANSACTION
   PRINT 'The database update failed'
END
GO
