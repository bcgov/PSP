-- Script generated by Aqua Data Studio Schema Synchronization for MS SQL Server 2016 on Fri Oct 22 23:01:02 PDT 2021
-- Execute this script on:
-- 		PIMS_S11_01/<All Schemas> - This database/schema will be modified
-- to synchronize it with MS SQL Server 2016:
-- 		PIMS_S13_00/<All Schemas>

-- We recommend backing up the database prior to executing the script.

SET XACT_ABORT ON
GO
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE
GO
BEGIN TRANSACTION
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Drop trigger dbo.PIMS_LEASE_I_S_I_TR
PRINT N'Drop trigger dbo.PIMS_LEASE_I_S_I_TR'
GO
DROP TRIGGER [dbo].[PIMS_LEASE_I_S_I_TR]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Drop trigger dbo.PIMS_PIMPRV_A_S_IUD_TR
PRINT N'Drop trigger dbo.PIMS_PIMPRV_A_S_IUD_TR'
GO
DROP TRIGGER [dbo].[PIMS_PIMPRV_A_S_IUD_TR]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Drop foreign key constraint PIM_PIMPRU_PIM_PIMPRV_FK
PRINT N'Drop foreign key constraint PIM_PIMPRU_PIM_PIMPRV_FK'
GO
ALTER TABLE [dbo].[PIMS_PROPERTY_IMPROVEMENT]
	DROP CONSTRAINT [PIM_PIMPRU_PIM_PIMPRV_FK]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Drop index dbo.PIMPRV_PROPERTY_IMPROVEMENT_UOM_TYPE_CODE_IDX
PRINT N'Drop index dbo.PIMPRV_PROPERTY_IMPROVEMENT_UOM_TYPE_CODE_IDX'
GO
DROP INDEX [dbo].[PIMS_PROPERTY_IMPROVEMENT].[PIMPRV_PROPERTY_IMPROVEMENT_UOM_TYPE_CODE_IDX]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Drop trigger dbo.PIMS_PIMPRU_I_S_U_TR
PRINT N'Drop trigger dbo.PIMS_PIMPRU_I_S_U_TR'
GO
DROP TRIGGER [dbo].[PIMS_PIMPRU_I_S_U_TR]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Drop trigger dbo.PIMS_PIMPRU_I_S_I_TR
PRINT N'Drop trigger dbo.PIMS_PIMPRU_I_S_I_TR'
GO
DROP TRIGGER [dbo].[PIMS_PIMPRU_I_S_I_TR]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Drop trigger dbo.PIMS_TENANT_I_S_U_TR
PRINT N'Drop trigger dbo.PIMS_TENANT_I_S_U_TR'
GO
DROP TRIGGER [dbo].[PIMS_TENANT_I_S_U_TR]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Drop trigger dbo.PIMS_LEASE_I_S_U_TR
PRINT N'Drop trigger dbo.PIMS_LEASE_I_S_U_TR'
GO
DROP TRIGGER [dbo].[PIMS_LEASE_I_S_U_TR]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Drop trigger dbo.PIMS_LEASE_A_S_IUD_TR
PRINT N'Drop trigger dbo.PIMS_LEASE_A_S_IUD_TR'
GO
DROP TRIGGER [dbo].[PIMS_LEASE_A_S_IUD_TR]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Drop trigger dbo.PIMS_ORG_A_S_IUD_TR
PRINT N'Drop trigger dbo.PIMS_ORG_A_S_IUD_TR'
GO
DROP TRIGGER [dbo].[PIMS_ORG_A_S_IUD_TR]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Drop trigger dbo.PIMS_PIMPRV_I_S_I_TR
PRINT N'Drop trigger dbo.PIMS_PIMPRV_I_S_I_TR'
GO
DROP TRIGGER [dbo].[PIMS_PIMPRV_I_S_I_TR]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Drop trigger dbo.PIMS_TENANT_I_S_I_TR
PRINT N'Drop trigger dbo.PIMS_TENANT_I_S_I_TR'
GO
DROP TRIGGER [dbo].[PIMS_TENANT_I_S_I_TR]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Drop trigger dbo.PIMS_PERSON_A_S_IUD_TR
PRINT N'Drop trigger dbo.PIMS_PERSON_A_S_IUD_TR'
GO
DROP TRIGGER [dbo].[PIMS_PERSON_A_S_IUD_TR]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Drop trigger dbo.PIMS_ORG_I_S_I_TR
PRINT N'Drop trigger dbo.PIMS_ORG_I_S_I_TR'
GO
DROP TRIGGER [dbo].[PIMS_ORG_I_S_I_TR]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Drop trigger dbo.PIMS_PERSON_I_S_U_TR
PRINT N'Drop trigger dbo.PIMS_PERSON_I_S_U_TR'
GO
DROP TRIGGER [dbo].[PIMS_PERSON_I_S_U_TR]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Drop trigger dbo.PIMS_PIMPRV_I_S_U_TR
PRINT N'Drop trigger dbo.PIMS_PIMPRV_I_S_U_TR'
GO
DROP TRIGGER [dbo].[PIMS_PIMPRV_I_S_U_TR]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Drop trigger dbo.PIMS_ORG_I_S_U_TR
PRINT N'Drop trigger dbo.PIMS_ORG_I_S_U_TR'
GO
DROP TRIGGER [dbo].[PIMS_ORG_I_S_U_TR]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Drop trigger dbo.PIMS_PROJCT_A_S_IUD_TR
PRINT N'Drop trigger dbo.PIMS_PROJCT_A_S_IUD_TR'
GO
DROP TRIGGER [dbo].[PIMS_PROJCT_A_S_IUD_TR]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Drop trigger dbo.PIMS_TENANT_A_S_IUD_TR
PRINT N'Drop trigger dbo.PIMS_TENANT_A_S_IUD_TR'
GO
DROP TRIGGER [dbo].[PIMS_TENANT_A_S_IUD_TR]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Drop trigger dbo.PIMS_ADDRSS_I_S_U_TR
PRINT N'Drop trigger dbo.PIMS_ADDRSS_I_S_U_TR'
GO
DROP TRIGGER [dbo].[PIMS_ADDRSS_I_S_U_TR]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Drop trigger dbo.PIMS_ADDRSS_A_S_IUD_TR
PRINT N'Drop trigger dbo.PIMS_ADDRSS_A_S_IUD_TR'
GO
DROP TRIGGER [dbo].[PIMS_ADDRSS_A_S_IUD_TR]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Drop trigger dbo.PIMS_ADDRSS_I_S_I_TR
PRINT N'Drop trigger dbo.PIMS_ADDRSS_I_S_I_TR'
GO
DROP TRIGGER [dbo].[PIMS_ADDRSS_I_S_I_TR]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Drop trigger dbo.PIMS_PERSON_I_S_I_TR
PRINT N'Drop trigger dbo.PIMS_PERSON_I_S_I_TR'
GO
DROP TRIGGER [dbo].[PIMS_PERSON_I_S_I_TR]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Drop view dbo.PIMS_PROPERTY_BOUNDARY_VW
PRINT N'Drop view dbo.PIMS_PROPERTY_BOUNDARY_VW'
GO
DROP VIEW [dbo].[PIMS_PROPERTY_BOUNDARY_VW]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Drop view dbo.PIMS_PROPERTY_LOCATION_VW
PRINT N'Drop view dbo.PIMS_PROPERTY_LOCATION_VW'
GO
DROP VIEW [dbo].[PIMS_PROPERTY_LOCATION_VW]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Drop primary key constraint PIMPRU_PK
PRINT N'Drop primary key constraint PIMPRU_PK'
GO
ALTER TABLE [dbo].[PIMS_PROPERTY_IMPROVEMENT_UOM_TYPE]
	DROP CONSTRAINT [PIMPRU_PK]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Drop procedure dbo.pims_error_handling
PRINT N'Drop procedure dbo.pims_error_handling'
GO
DROP PROCEDURE [dbo].[pims_error_handling]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Drop sequence dbo.PIMS_LEASE_ACTIVITY_H_ID_SEQ
PRINT N'Drop sequence dbo.PIMS_LEASE_ACTIVITY_H_ID_SEQ'
GO
DROP SEQUENCE [dbo].[PIMS_LEASE_ACTIVITY_H_ID_SEQ]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Drop sequence dbo.PIMS_LEASE_ACTIVITY_PERIOD_H_ID_SEQ
PRINT N'Drop sequence dbo.PIMS_LEASE_ACTIVITY_PERIOD_H_ID_SEQ'
GO
DROP SEQUENCE [dbo].[PIMS_LEASE_ACTIVITY_PERIOD_H_ID_SEQ]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Drop sequence dbo.PIMS_EXPECTED_AMOUNT_H_ID_SEQ
PRINT N'Drop sequence dbo.PIMS_EXPECTED_AMOUNT_H_ID_SEQ'
GO
DROP SEQUENCE [dbo].[PIMS_EXPECTED_AMOUNT_H_ID_SEQ]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Drop sequence dbo.PIMS_EXPECTED_AMOUNT_ID_SEQ
PRINT N'Drop sequence dbo.PIMS_EXPECTED_AMOUNT_ID_SEQ'
GO
DROP SEQUENCE [dbo].[PIMS_EXPECTED_AMOUNT_ID_SEQ]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create table etl.ETL_ERROR_LOG
PRINT N'Create table etl.ETL_ERROR_LOG'
GO
CREATE TABLE [etl].[ETL_ERROR_LOG]  ( 
	[ERROR_TIME]          	datetime NULL,
	[ERROR_OPERATION_NAME]	nvarchar(100) NULL,
	[ERROR_TASK_NAME]     	nvarchar(100) NULL,
	[ERROR_ETL_NAME]      	nvarchar(100) NULL,
	[ERROR_ROW]           	nvarchar(max) NULL 
	)
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Alter table etl.ETL_CONTACT_METHOD_LOG
PRINT N'Alter table etl.ETL_CONTACT_METHOD_LOG'
GO
ALTER TABLE [etl].[ETL_CONTACT_METHOD_LOG] ADD DEFAULT (getutcdate()) FOR [LAST_UPDATE_DATETIME]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO
ALTER TABLE [etl].[ETL_CONTACT_METHOD_LOG] ADD DEFAULT (user_name()) FOR [LAST_UPDATE_USERID]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create table dbo.PIMS_STATIC_VARIABLE
PRINT N'Create table dbo.PIMS_STATIC_VARIABLE'
GO
CREATE TABLE [dbo].[PIMS_STATIC_VARIABLE]  ( 
	[STATIC_VARIABLE_NAME]      	nvarchar(100) NOT NULL,
	[STATIC_VARIABLE_VALUE]     	nvarchar(100) NOT NULL,
	[CONCURRENCY_CONTROL_NUMBER]	bigint NOT NULL DEFAULT ((1)),
	[DB_CREATE_TIMESTAMP]       	datetime NOT NULL DEFAULT (getutcdate()),
	[DB_CREATE_USERID]          	nvarchar(30) NOT NULL DEFAULT (user_name()),
	[DB_LAST_UPDATE_TIMESTAMP]  	datetime NOT NULL DEFAULT (getutcdate()),
	[DB_LAST_UPDATE_USERID]     	nvarchar(30) NOT NULL DEFAULT (user_name()),
	PRIMARY KEY CLUSTERED([STATIC_VARIABLE_NAME])
 ON [PRIMARY])
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create table etl.ETL_PROPERTY_ERROR_LOG
PRINT N'Create table etl.ETL_PROPERTY_ERROR_LOG'
GO
CREATE TABLE [etl].[ETL_PROPERTY_ERROR_LOG]  ( 
	[CIVIC_ADDRESS]                    	nvarchar(100) NULL,
	[MUNICIPALITY_NAME]                	nvarchar(40) NULL,
	[DESCRIPTION]                      	nvarchar(2000) NULL,
	[PID]                              	int NULL,
	[PIN]                              	int NULL,
	[LAND_LEGAL_DESCRIPTION]           	nvarchar(2000) NULL,
	[ZONING]                           	nvarchar(2) NULL,
	[ZONING_POTENTIAL]                 	nvarchar(30) NULL,
	[PROPERTY_ID]                      	int NULL,
	[PROPERTY_TYPE_CODE]               	nvarchar(4) NULL,
	[PROPERTY_CLASSIFICATION_TYPE_CODE]	nvarchar(8) NULL,
	[ErrorCode]                        	int NULL,
	[ErrorColumn]                      	int NULL 
	)
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create sequence dbo.PIMS_LEASE_TERM_ID_SEQ
PRINT N'Create sequence dbo.PIMS_LEASE_TERM_ID_SEQ'
GO
CREATE SEQUENCE [dbo].[PIMS_LEASE_TERM_ID_SEQ]
	AS bigint
	START WITH 1
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	NO CYCLE
	CACHE 50
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create table dbo.PIMS_LEASE_INITIATOR_TYPE
PRINT N'Create table dbo.PIMS_LEASE_INITIATOR_TYPE'
GO
CREATE TABLE [dbo].[PIMS_LEASE_INITIATOR_TYPE]  ( 
	[LEASE_INITIATOR_TYPE_CODE] 	nvarchar(20) NOT NULL,
	[DESCRIPTION]               	nvarchar(200) NOT NULL,
	[IS_DISABLED]               	bit NOT NULL DEFAULT (CONVERT([bit],(0))),
	[DISPLAY_ORDER]             	int NULL,
	[CONCURRENCY_CONTROL_NUMBER]	bigint NOT NULL DEFAULT ((1)),
	[DB_CREATE_TIMESTAMP]       	datetime NOT NULL DEFAULT (getutcdate()),
	[DB_CREATE_USERID]          	nvarchar(30) NOT NULL DEFAULT (user_name()),
	[DB_LAST_UPDATE_TIMESTAMP]  	datetime NOT NULL DEFAULT (getutcdate()),
	[DB_LAST_UPDATE_USERID]     	nvarchar(30) NOT NULL DEFAULT (user_name()),
	PRIMARY KEY CLUSTERED([LEASE_INITIATOR_TYPE_CODE])
 ON [PRIMARY])
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'Code value of the initiator of the lease' , 
	@level0type = N'Schema', @level0name = N'dbo', 
	@level1type = N'Table', @level1name = N'PIMS_LEASE_INITIATOR_TYPE', 
	@level2type = N'Column', @level2name = N'LEASE_INITIATOR_TYPE_CODE'
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'Description of the initiator of the lease' , 
	@level0type = N'Schema', @level0name = N'dbo', 
	@level1type = N'Table', @level1name = N'PIMS_LEASE_INITIATOR_TYPE', 
	@level2type = N'Column', @level2name = N'DESCRIPTION'
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'Describes the initiator of the lease' , 
	@level0type = N'Schema', @level0name = N'dbo', 
	@level1type = N'Table', @level1name = N'PIMS_LEASE_INITIATOR_TYPE'
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create table dbo.PIMS_LEASE_RESPONSIBILITY_TYPE
PRINT N'Create table dbo.PIMS_LEASE_RESPONSIBILITY_TYPE'
GO
CREATE TABLE [dbo].[PIMS_LEASE_RESPONSIBILITY_TYPE]  ( 
	[LEASE_RESPONSIBILITY_TYPE_CODE]	nvarchar(20) NOT NULL,
	[DESCRIPTION]                   	nvarchar(200) NOT NULL,
	[IS_DISABLED]                   	bit NOT NULL DEFAULT (CONVERT([bit],(0))),
	[DISPLAY_ORDER]                 	int NULL,
	[CONCURRENCY_CONTROL_NUMBER]    	bigint NOT NULL DEFAULT ((1)),
	[DB_CREATE_TIMESTAMP]           	datetime NOT NULL DEFAULT (getutcdate()),
	[DB_CREATE_USERID]              	nvarchar(30) NOT NULL DEFAULT (user_name()),
	[DB_LAST_UPDATE_TIMESTAMP]      	datetime NOT NULL DEFAULT (getutcdate()),
	[DB_LAST_UPDATE_USERID]         	nvarchar(30) NOT NULL DEFAULT (user_name()),
	PRIMARY KEY CLUSTERED([LEASE_RESPONSIBILITY_TYPE_CODE])
 ON [PRIMARY])
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'Code value of the organization responsible for this lease' , 
	@level0type = N'Schema', @level0name = N'dbo', 
	@level1type = N'Table', @level1name = N'PIMS_LEASE_RESPONSIBILITY_TYPE', 
	@level2type = N'Column', @level2name = N'LEASE_RESPONSIBILITY_TYPE_CODE'
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'Description of the organization responsible for this lease' , 
	@level0type = N'Schema', @level0name = N'dbo', 
	@level1type = N'Table', @level1name = N'PIMS_LEASE_RESPONSIBILITY_TYPE', 
	@level2type = N'Column', @level2name = N'DESCRIPTION'
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'Describes which organization is responsible for this lease' , 
	@level0type = N'Schema', @level0name = N'dbo', 
	@level1type = N'Table', @level1name = N'PIMS_LEASE_RESPONSIBILITY_TYPE'
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Alter table dbo.PIMS_ADDRESS
PRINT N'Alter table dbo.PIMS_ADDRESS'
GO
ALTER TABLE [dbo].[PIMS_ADDRESS]
	ADD [COMMENT] nvarchar(2000) NULL
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Alter table dbo.PIMS_PERSON
PRINT N'Alter table dbo.PIMS_PERSON'
GO
ALTER TABLE [dbo].[PIMS_PERSON]
	ADD [PREFERRED_NAME] nvarchar(200) NULL
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Alter table dbo.PIMS_LEASE
PRINT N'Alter table dbo.PIMS_LEASE'
GO
ALTER TABLE [dbo].[PIMS_LEASE] ALTER COLUMN [RENEWAL_COUNT] smallint NULL
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO
ALTER TABLE [dbo].[PIMS_LEASE] DROP CONSTRAINT [LEASE_RENEWAL_COUNT_DEF]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO
EXEC sp_updateextendedproperty 
	@name = N'MS_Description', @value = N'Number of exercised renewals' , 
	@level0type = N'Schema', @level0name = N'dbo', 
	@level1type = N'Table', @level1name = N'PIMS_LEASE', 
	@level2type = N'Column', @level2name = N'RENEWAL_COUNT'
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO
EXEC sp_updateextendedproperty 
	@name = N'MS_Description', @value = N'Number of months included in lease renewal' , 
	@level0type = N'Schema', @level0name = N'dbo', 
	@level1type = N'Table', @level1name = N'PIMS_LEASE', 
	@level2type = N'Column', @level2name = N'RENEWAL_TERM_MONTHS'
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO
ALTER TABLE [dbo].[PIMS_LEASE]
	ADD [LEASE_INITIATOR_TYPE_CODE] nvarchar(20) NOT NULL, 
	[LEASE_RESPONSIBILITY_TYPE_CODE] nvarchar(20) NOT NULL, 
	[RESPONSIBILITY_EFFECTIVE_DATE] datetime NULL, 
	[IS_SUBJECT_TO_RTA] bit NULL CONSTRAINT [LEASE_IS_SUBJECT_TO_RTA_DEF] DEFAULT (CONVERT([bit],(0))), 
	[IS_COMM_BLDG] bit NULL CONSTRAINT [LEASE_IS_COMM_BLDG_DEF] DEFAULT (CONVERT([bit],(0))), 
	[IS_OTHER_IMPROVEMENT] bit NULL CONSTRAINT [LEASE_IS_OTHER_IMPROVEMENT_DEF] DEFAULT (CONVERT([bit],(0)))
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'Date current responsibility came into effect for this lease' , 
	@level0type = N'Schema', @level0name = N'dbo', 
	@level1type = N'Table', @level1name = N'PIMS_LEASE', 
	@level2type = N'Column', @level2name = N'RESPONSIBILITY_EFFECTIVE_DATE'
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'Is subject the Residential Tenancy Act' , 
	@level0type = N'Schema', @level0name = N'dbo', 
	@level1type = N'Table', @level1name = N'PIMS_LEASE', 
	@level2type = N'Column', @level2name = N'IS_SUBJECT_TO_RTA'
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'Is a commercial building' , 
	@level0type = N'Schema', @level0name = N'dbo', 
	@level1type = N'Table', @level1name = N'PIMS_LEASE', 
	@level2type = N'Column', @level2name = N'IS_COMM_BLDG'
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'Is improvement of another description' , 
	@level0type = N'Schema', @level0name = N'dbo', 
	@level1type = N'Table', @level1name = N'PIMS_LEASE', 
	@level2type = N'Column', @level2name = N'IS_OTHER_IMPROVEMENT'
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO
ALTER TABLE [dbo].[PIMS_LEASE]
	DROP COLUMN [TERM_START_DATE], [TERM_EXPIRY_DATE], [TERM_RENEWAL_DATE]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create table dbo.PIMS_LEASE_TERM_STATUS_TYPE
PRINT N'Create table dbo.PIMS_LEASE_TERM_STATUS_TYPE'
GO
CREATE TABLE [dbo].[PIMS_LEASE_TERM_STATUS_TYPE]  ( 
	[LEASE_TERM_STATUS_TYPE_CODE]	nvarchar(20) NOT NULL,
	[DESCRIPTION]                	nvarchar(200) NOT NULL,
	[IS_DISABLED]                	bit NOT NULL DEFAULT (CONVERT([bit],(0))),
	[DISPLAY_ORDER]              	int NULL,
	[CONCURRENCY_CONTROL_NUMBER] 	bigint NOT NULL DEFAULT ((1)),
	[DB_CREATE_TIMESTAMP]        	datetime NOT NULL DEFAULT (getutcdate()),
	[DB_CREATE_USERID]           	nvarchar(30) NOT NULL DEFAULT (user_name()),
	[DB_LAST_UPDATE_TIMESTAMP]   	datetime NOT NULL DEFAULT (getutcdate()),
	[DB_LAST_UPDATE_USERID]      	nvarchar(30) NOT NULL DEFAULT (user_name()),
	PRIMARY KEY CLUSTERED([LEASE_TERM_STATUS_TYPE_CODE])
 ON [PRIMARY])
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'Code value of the status of the lease term' , 
	@level0type = N'Schema', @level0name = N'dbo', 
	@level1type = N'Table', @level1name = N'PIMS_LEASE_TERM_STATUS_TYPE', 
	@level2type = N'Column', @level2name = N'LEASE_TERM_STATUS_TYPE_CODE'
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'Description of the status of the lease term' , 
	@level0type = N'Schema', @level0name = N'dbo', 
	@level1type = N'Table', @level1name = N'PIMS_LEASE_TERM_STATUS_TYPE', 
	@level2type = N'Column', @level2name = N'DESCRIPTION'
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'Describes the status of the lease term' , 
	@level0type = N'Schema', @level0name = N'dbo', 
	@level1type = N'Table', @level1name = N'PIMS_LEASE_TERM_STATUS_TYPE'
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create table dbo.PIMS_LEASE_TERM
PRINT N'Create table dbo.PIMS_LEASE_TERM'
GO
CREATE TABLE [dbo].[PIMS_LEASE_TERM]  ( 
	[LEASE_TERM_ID]                 	varchar(40) NOT NULL DEFAULT ('NEXT VALUE FOR [PIMS_LEASE_TERM_ID_SEQ]'),
	[LEASE_ID]                      	bigint NOT NULL,
	[LEASE_TERM_STATUS_TYPE_CODE]   	nvarchar(20) NOT NULL,
	[TERM_START_DATE]               	datetime NOT NULL,
	[TERM_EXPIRY_DATE]              	datetime NULL,
	[TERM_RENEWAL_DATE]             	datetime NULL,
	[CONCURRENCY_CONTROL_NUMBER]    	bigint NOT NULL DEFAULT ((1)),
	[APP_CREATE_TIMESTAMP]          	datetime NOT NULL DEFAULT (getutcdate()),
	[APP_CREATE_USERID]             	nvarchar(30) NOT NULL DEFAULT (user_name()),
	[APP_CREATE_USER_GUID]          	uniqueidentifier NULL,
	[APP_CREATE_USER_DIRECTORY]     	nvarchar(30) NOT NULL DEFAULT (user_name()),
	[APP_LAST_UPDATE_TIMESTAMP]     	datetime NOT NULL DEFAULT (getutcdate()),
	[APP_LAST_UPDATE_USERID]        	nvarchar(30) NOT NULL DEFAULT (user_name()),
	[APP_LAST_UPDATE_USER_GUID]     	uniqueidentifier NULL,
	[APP_LAST_UPDATE_USER_DIRECTORY]	nvarchar(30) NOT NULL DEFAULT (user_name()),
	[DB_CREATE_TIMESTAMP]           	datetime NOT NULL DEFAULT (getutcdate()),
	[DB_CREATE_USERID]              	nvarchar(30) NOT NULL DEFAULT (user_name()),
	[DB_LAST_UPDATE_TIMESTAMP]      	datetime NOT NULL DEFAULT (getutcdate()),
	[DB_LAST_UPDATE_USERID]         	nvarchar(30) NOT NULL DEFAULT (user_name()),
	PRIMARY KEY CLUSTERED([LEASE_TERM_ID])
 ON [PRIMARY])
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'Start date of the current term of the lease/licence' , 
	@level0type = N'Schema', @level0name = N'dbo', 
	@level1type = N'Table', @level1name = N'PIMS_LEASE_TERM', 
	@level2type = N'Column', @level2name = N'TERM_START_DATE'
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'Expiry date of the current term of the lease/licence' , 
	@level0type = N'Schema', @level0name = N'dbo', 
	@level1type = N'Table', @level1name = N'PIMS_LEASE_TERM', 
	@level2type = N'Column', @level2name = N'TERM_EXPIRY_DATE'
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'Renewal date of the current term of the lease/licence' , 
	@level0type = N'Schema', @level0name = N'dbo', 
	@level1type = N'Table', @level1name = N'PIMS_LEASE_TERM', 
	@level2type = N'Column', @level2name = N'TERM_RENEWAL_DATE'
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create sequence dbo.PIMS_LEASE_PAYMENT_FORECAST_ID_SEQ
PRINT N'Create sequence dbo.PIMS_LEASE_PAYMENT_FORECAST_ID_SEQ'
GO
CREATE SEQUENCE [dbo].[PIMS_LEASE_PAYMENT_FORECAST_ID_SEQ]
	AS bigint
	START WITH 1
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	NO CYCLE
	CACHE 50
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create table dbo.PIMS_LEASE_PAYMENT_PERIOD
PRINT N'Create table dbo.PIMS_LEASE_PAYMENT_PERIOD'
GO
CREATE TABLE [dbo].[PIMS_LEASE_PAYMENT_PERIOD]  ( 
	[LEASE_PAYMENT_PERIOD_ID]       	bigint NOT NULL DEFAULT (NEXT VALUE FOR [PIMS_LEASE_PAYMENT_PERIOD_ID_SEQ]),
	[PERIOD_START_DATE]             	date NOT NULL,
	[IS_PERIOD_CLOSED]              	bit NOT NULL DEFAULT (CONVERT([bit],(0))),
	[CONCURRENCY_CONTROL_NUMBER]    	bigint NOT NULL DEFAULT ((1)),
	[APP_CREATE_TIMESTAMP]          	datetime NOT NULL DEFAULT (getutcdate()),
	[APP_CREATE_USERID]             	nvarchar(30) NOT NULL DEFAULT (user_name()),
	[APP_CREATE_USER_GUID]          	uniqueidentifier NULL,
	[APP_CREATE_USER_DIRECTORY]     	nvarchar(30) NOT NULL DEFAULT (user_name()),
	[APP_LAST_UPDATE_TIMESTAMP]     	datetime NOT NULL DEFAULT (getutcdate()),
	[APP_LAST_UPDATE_USERID]        	nvarchar(30) NOT NULL DEFAULT (user_name()),
	[APP_LAST_UPDATE_USER_GUID]     	uniqueidentifier NULL,
	[APP_LAST_UPDATE_USER_DIRECTORY]	nvarchar(30) NOT NULL DEFAULT (user_name()),
	[DB_CREATE_TIMESTAMP]           	datetime NOT NULL DEFAULT (getutcdate()),
	[DB_CREATE_USERID]              	nvarchar(30) NOT NULL DEFAULT (user_name()),
	[DB_LAST_UPDATE_TIMESTAMP]      	datetime NOT NULL DEFAULT (getutcdate()),
	[DB_LAST_UPDATE_USERID]         	nvarchar(30) NOT NULL DEFAULT (user_name()),
	PRIMARY KEY CLUSTERED([LEASE_PAYMENT_PERIOD_ID])
 ON [PRIMARY])
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create table dbo.PIMS_LEASE_PAYMENT_STATUS_TYPE
PRINT N'Create table dbo.PIMS_LEASE_PAYMENT_STATUS_TYPE'
GO
CREATE TABLE [dbo].[PIMS_LEASE_PAYMENT_STATUS_TYPE]  ( 
	[LEASE_PAYMENT_STATUS_TYPE_CODE]	nvarchar(20) NOT NULL,
	[DESCRIPTION]                   	nvarchar(200) NOT NULL,
	[IS_DISABLED]                   	bit NOT NULL DEFAULT (CONVERT([bit],(0))),
	[DISPLAY_ORDER]                 	int NULL,
	[CONCURRENCY_CONTROL_NUMBER]    	bigint NOT NULL DEFAULT ((1)),
	[DB_CREATE_TIMESTAMP]           	datetime NOT NULL DEFAULT (getutcdate()),
	[DB_CREATE_USERID]              	nvarchar(30) NOT NULL DEFAULT (user_name()),
	[DB_LAST_UPDATE_TIMESTAMP]      	datetime NOT NULL DEFAULT (getutcdate()),
	[DB_LAST_UPDATE_USERID]         	nvarchar(30) NOT NULL DEFAULT (user_name()),
	PRIMARY KEY CLUSTERED([LEASE_PAYMENT_STATUS_TYPE_CODE])
 ON [PRIMARY])
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'Payment status type code' , 
	@level0type = N'Schema', @level0name = N'dbo', 
	@level1type = N'Table', @level1name = N'PIMS_LEASE_PAYMENT_STATUS_TYPE', 
	@level2type = N'Column', @level2name = N'LEASE_PAYMENT_STATUS_TYPE_CODE'
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'Payment status type description' , 
	@level0type = N'Schema', @level0name = N'dbo', 
	@level1type = N'Table', @level1name = N'PIMS_LEASE_PAYMENT_STATUS_TYPE', 
	@level2type = N'Column', @level2name = N'DESCRIPTION'
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'Is this code disabled?' , 
	@level0type = N'Schema', @level0name = N'dbo', 
	@level1type = N'Table', @level1name = N'PIMS_LEASE_PAYMENT_STATUS_TYPE', 
	@level2type = N'Column', @level2name = N'IS_DISABLED'
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'Display order of the descriptions' , 
	@level0type = N'Schema', @level0name = N'dbo', 
	@level1type = N'Table', @level1name = N'PIMS_LEASE_PAYMENT_STATUS_TYPE', 
	@level2type = N'Column', @level2name = N'DISPLAY_ORDER'
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'Describes the status of forecast payments' , 
	@level0type = N'Schema', @level0name = N'dbo', 
	@level1type = N'Table', @level1name = N'PIMS_LEASE_PAYMENT_STATUS_TYPE'
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create table dbo.PIMS_LEASE_PAYMENT_FORECAST
PRINT N'Create table dbo.PIMS_LEASE_PAYMENT_FORECAST'
GO
CREATE TABLE [dbo].[PIMS_LEASE_PAYMENT_FORECAST]  ( 
	[LEASE_PAYMENT_FORECAST_ID]     	bigint NOT NULL DEFAULT (NEXT VALUE FOR [PIMS_LEASE_PAYMENT_FORECAST_ID_SEQ]),
	[LEASE_TERM_ID]                 	varchar(40) NOT NULL,
	[LEASE_PAYMENT_PERIOD_ID]       	bigint NOT NULL,
	[LEASE_PAYMENT_STATUS_TYPE_CODE]	nvarchar(20) NOT NULL,
	[PAYMENT_DUE_DATE]              	datetime NOT NULL,
	[FORECAST_PAYMENT_PRE_TAX]      	money NOT NULL,
	[FORECAST_PAYMENT_PST]          	money NOT NULL,
	[FORECAST_PAYMENT_GST]          	money NOT NULL,
	[FORECAST_PAYMENT_TOTAL]        	money NOT NULL,
	[CONCURRENCY_CONTROL_NUMBER]    	bigint NOT NULL DEFAULT ((1)),
	[APP_CREATE_TIMESTAMP]          	datetime NOT NULL DEFAULT (getutcdate()),
	[APP_CREATE_USERID]             	nvarchar(30) NOT NULL DEFAULT (user_name()),
	[APP_CREATE_USER_GUID]          	uniqueidentifier NULL,
	[APP_CREATE_USER_DIRECTORY]     	nvarchar(30) NOT NULL DEFAULT (user_name()),
	[APP_LAST_UPDATE_TIMESTAMP]     	datetime NOT NULL DEFAULT (getutcdate()),
	[APP_LAST_UPDATE_USERID]        	nvarchar(30) NOT NULL DEFAULT (user_name()),
	[APP_LAST_UPDATE_USER_GUID]     	uniqueidentifier NULL,
	[APP_LAST_UPDATE_USER_DIRECTORY]	nvarchar(30) NOT NULL DEFAULT (user_name()),
	[DB_CREATE_TIMESTAMP]           	datetime NOT NULL DEFAULT (getutcdate()),
	[DB_CREATE_USERID]              	nvarchar(30) NOT NULL DEFAULT (user_name()),
	[DB_LAST_UPDATE_TIMESTAMP]      	datetime NOT NULL DEFAULT (getutcdate()),
	[DB_LAST_UPDATE_USERID]         	nvarchar(30) NOT NULL DEFAULT (user_name()),
	PRIMARY KEY CLUSTERED([LEASE_PAYMENT_FORECAST_ID])
 ON [PRIMARY])
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create table dbo.PIMS_LEASE_PAYMENT_METHOD_TYPE
PRINT N'Create table dbo.PIMS_LEASE_PAYMENT_METHOD_TYPE'
GO
CREATE TABLE [dbo].[PIMS_LEASE_PAYMENT_METHOD_TYPE]  ( 
	[LEASE_PAYMENT_METHOD_TYPE_CODE]	nvarchar(20) NOT NULL,
	[DESCRIPTION]                   	nvarchar(200) NOT NULL,
	[IS_DISABLED]                   	bit NOT NULL DEFAULT (CONVERT([bit],(0))),
	[DISPLAY_ORDER]                 	int NULL,
	[CONCURRENCY_CONTROL_NUMBER]    	bigint NOT NULL DEFAULT ((1)),
	[DB_CREATE_TIMESTAMP]           	datetime NOT NULL DEFAULT (getutcdate()),
	[DB_CREATE_USERID]              	nvarchar(30) NOT NULL DEFAULT (user_name()),
	[DB_LAST_UPDATE_TIMESTAMP]      	datetime NOT NULL DEFAULT (getutcdate()),
	[DB_LAST_UPDATE_USERID]         	nvarchar(30) NOT NULL DEFAULT (user_name()),
	PRIMARY KEY CLUSTERED([LEASE_PAYMENT_METHOD_TYPE_CODE])
 ON [PRIMARY])
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'Payment method type code' , 
	@level0type = N'Schema', @level0name = N'dbo', 
	@level1type = N'Table', @level1name = N'PIMS_LEASE_PAYMENT_METHOD_TYPE', 
	@level2type = N'Column', @level2name = N'LEASE_PAYMENT_METHOD_TYPE_CODE'
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'Payment method type description' , 
	@level0type = N'Schema', @level0name = N'dbo', 
	@level1type = N'Table', @level1name = N'PIMS_LEASE_PAYMENT_METHOD_TYPE', 
	@level2type = N'Column', @level2name = N'DESCRIPTION'
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'Is this code disabled?' , 
	@level0type = N'Schema', @level0name = N'dbo', 
	@level1type = N'Table', @level1name = N'PIMS_LEASE_PAYMENT_METHOD_TYPE', 
	@level2type = N'Column', @level2name = N'IS_DISABLED'
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'Display order of the descriptions' , 
	@level0type = N'Schema', @level0name = N'dbo', 
	@level1type = N'Table', @level1name = N'PIMS_LEASE_PAYMENT_METHOD_TYPE', 
	@level2type = N'Column', @level2name = N'DISPLAY_ORDER'
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create table dbo.PIMS_LEASE_PAYMENT
PRINT N'Create table dbo.PIMS_LEASE_PAYMENT'
GO
CREATE TABLE [dbo].[PIMS_LEASE_PAYMENT]  ( 
	[LEASE_PAYMENT_ID]              	bigint NOT NULL DEFAULT (NEXT VALUE FOR [PIMS_LEASE_PAYMENT_ID_SEQ]),
	[LEASE_TERM_ID]                 	varchar(40) NOT NULL,
	[LEASE_PAYMENT_PERIOD_ID]       	bigint NOT NULL,
	[LEASE_PAYMENT_METHOD_TYPE_CODE]	nvarchar(20) NOT NULL,
	[PAYMENT_RECEIVED_DATE]         	datetime NOT NULL,
	[PAYMENT_AMOUNT_PRE_TAX]        	money NOT NULL,
	[PAYMENT_AMOUNT_PST]            	money NOT NULL,
	[PAYMENT_AMOUNT_GST]            	money NOT NULL,
	[PAYMENT_AMOUNT_TOTAL]          	money NOT NULL,
	[NOTE]                          	nvarchar(2000) NULL,
	[CONCURRENCY_CONTROL_NUMBER]    	bigint NOT NULL DEFAULT ((1)),
	[APP_CREATE_TIMESTAMP]          	datetime NOT NULL DEFAULT (getutcdate()),
	[APP_CREATE_USERID]             	nvarchar(30) NOT NULL DEFAULT (user_name()),
	[APP_CREATE_USER_GUID]          	uniqueidentifier NULL,
	[APP_CREATE_USER_DIRECTORY]     	nvarchar(30) NOT NULL DEFAULT (user_name()),
	[APP_LAST_UPDATE_TIMESTAMP]     	datetime NOT NULL DEFAULT (getutcdate()),
	[APP_LAST_UPDATE_USERID]        	nvarchar(30) NOT NULL DEFAULT (user_name()),
	[APP_LAST_UPDATE_USER_GUID]     	uniqueidentifier NULL,
	[APP_LAST_UPDATE_USER_DIRECTORY]	nvarchar(30) NOT NULL DEFAULT (user_name()),
	[DB_CREATE_TIMESTAMP]           	datetime NOT NULL DEFAULT (getutcdate()),
	[DB_CREATE_USERID]              	nvarchar(30) NOT NULL DEFAULT (user_name()),
	[DB_LAST_UPDATE_TIMESTAMP]      	datetime NOT NULL DEFAULT (getutcdate()),
	[DB_LAST_UPDATE_USERID]         	nvarchar(30) NOT NULL DEFAULT (user_name()),
	PRIMARY KEY CLUSTERED([LEASE_PAYMENT_ID])
 ON [PRIMARY])
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create table pmbc.PMBC_PARCEL_POLYGON_FABRIC
PRINT N'Create table pmbc.PMBC_PARCEL_POLYGON_FABRIC'
GO
CREATE TABLE [pmbc].[PMBC_PARCEL_POLYGON_FABRIC]  ( 
	[PARCEL_FABRIC_POLY_ID]	int NOT NULL,
	[GLOBAL_UID]           	nvarchar(254) NULL,
	[PARCEL_NAME]          	nvarchar(50) NULL,
	[PLAN_ID]              	int NULL,
	[PLAN_NUMBER]          	nvarchar(128) NULL,
	[PIN]                  	int NULL,
	[PID]                  	nvarchar(9) NULL,
	[PID_NUMBER]           	int NULL,
	[SOURCE_PARCEL_ID]     	nvarchar(50) NULL,
	[PARCEL_STATUS]        	nvarchar(20) NULL,
	[PARCEL_CLASS]         	nvarchar(50) NULL,
	[OWNER_TYPE]           	nvarchar(50) NULL,
	[PARCEL_START_DATE]    	datetime NULL,
	[SURVEY_DESIGNATION_1] 	nvarchar(30) NULL,
	[SURVEY_DESIGNATION_2] 	nvarchar(30) NULL,
	[SURVEY_DESIGNATION_3] 	nvarchar(30) NULL,
	[LEGAL_DESCRIPTION]    	nvarchar(2000) NULL,
	[MUNICIPALITY]         	nvarchar(254) NULL,
	[REGIONAL_DISTRICT]    	nvarchar(50) NULL,
	[IS_REMAINDER_IND]     	nvarchar(3) NULL,
	[GEOMETRY_SOURCE]      	nvarchar(50) NULL,
	[POSITIONAL_ERROR]     	bigint NULL,
	[ERROR_REPORTED_BY]    	nvarchar(50) NULL,
	[CAPTURE_METHOD]       	nvarchar(50) NULL,
	[COMPILED_IND]         	nvarchar(5) NULL,
	[STATED_AREA]          	nvarchar(50) NULL,
	[WHEN_CREATED]         	datetime NULL,
	[WHEN_UPDATED]         	datetime NULL,
	[FEATURE_AREA_SQM]     	bigint NULL,
	[FEATURE_LENGTH_M]     	bigint NULL,
	[SHAPE]                	[sys].[geometry] NULL,
	[OBJECTID]             	numeric(38,0) NULL,
	[SE_ANNO_CAD_DATA]     	varbinary(max) NULL,
	PRIMARY KEY CLUSTERED([PARCEL_FABRIC_POLY_ID])
 ON [PRIMARY])
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'PARCEL_FABRIC_POLY_ID is a system generated unique identification number.' , 
	@level0type = N'Schema', @level0name = N'pmbc', 
	@level1type = N'Table', @level1name = N'PMBC_PARCEL_POLYGON_FABRIC', 
	@level2type = N'Column', @level2name = N'PARCEL_FABRIC_POLY_ID'
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'GLOBAL_UID is a unique global identifier (GUID) for the parcel.' , 
	@level0type = N'Schema', @level0name = N'pmbc', 
	@level1type = N'Table', @level1name = N'PMBC_PARCEL_POLYGON_FABRIC', 
	@level2type = N'Column', @level2name = N'GLOBAL_UID'
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'PARCEL_NAME is the same as the PID, if there is one. If there is a PIN but no PID, then PARCEL_NAME is the PIN. If there is no PID nor PIN, then PARCEL_NAME is the parcel class value, e.g., COMMON OWNERSHIP, BUILDING STRATA, AIR SPACE, ROAD, PARK.' , 
	@level0type = N'Schema', @level0name = N'pmbc', 
	@level1type = N'Table', @level1name = N'PMBC_PARCEL_POLYGON_FABRIC', 
	@level2type = N'Column', @level2name = N'PARCEL_NAME'
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'PLAN_ID is the unique identifier of the land survey plan that corresponds to this parcel.' , 
	@level0type = N'Schema', @level0name = N'pmbc', 
	@level1type = N'Table', @level1name = N'PMBC_PARCEL_POLYGON_FABRIC', 
	@level2type = N'Column', @level2name = N'PLAN_ID'
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'PLAN_NUMBER is the Land Act, Land Title Act, or Strata Property Act Plan Number for the land survey plan that corresponds to this parcel, e.g., VIP1632, NO_PLAN.' , 
	@level0type = N'Schema', @level0name = N'pmbc', 
	@level1type = N'Table', @level1name = N'PMBC_PARCEL_POLYGON_FABRIC', 
	@level2type = N'Column', @level2name = N'PLAN_NUMBER'
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'PIN is the Crown Land Registry Parcel Identifier, if applicable.' , 
	@level0type = N'Schema', @level0name = N'pmbc', 
	@level1type = N'Table', @level1name = N'PMBC_PARCEL_POLYGON_FABRIC', 
	@level2type = N'Column', @level2name = N'PIN'
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'PID is the Land Title Register parcel identifier, a left-zero-padded nine-digit number that uniquely identifies a parcel in the land title register of in British Columbia. The registrar assigns PID numbers to parcels for which a title is being entered as' , 
	@level0type = N'Schema', @level0name = N'pmbc', 
	@level1type = N'Table', @level1name = N'PMBC_PARCEL_POLYGON_FABRIC', 
	@level2type = N'Column', @level2name = N'PID'
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'PID_NUMBER is the PID, without leading zeroes. PID is the Land Title Register parcel identifier, a nine-digit number that uniquely identifies a parcel in the land title register of in British Columbia. The registrar assigns PID numbers to parcels for whic' , 
	@level0type = N'Schema', @level0name = N'pmbc', 
	@level1type = N'Table', @level1name = N'PMBC_PARCEL_POLYGON_FABRIC', 
	@level2type = N'Column', @level2name = N'PID_NUMBER'
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'SOURCE_PARCEL_ID is the unique parcel identifier supplied by the source data provider. The value is intended to assist local governments by providing traceability back to the source data provider''s parcel ID. It will not be populated during on-going opera' , 
	@level0type = N'Schema', @level0name = N'pmbc', 
	@level1type = N'Table', @level1name = N'PMBC_PARCEL_POLYGON_FABRIC', 
	@level2type = N'Column', @level2name = N'SOURCE_PARCEL_ID'
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'PARCEL_STATUS is the status of the parcel, according to the Land Title Register or Crown Land Registry, as appropriate, i.e., ACTIVE, CANCELLED, INACTIVE, PENDING.' , 
	@level0type = N'Schema', @level0name = N'pmbc', 
	@level1type = N'Table', @level1name = N'PMBC_PARCEL_POLYGON_FABRIC', 
	@level2type = N'Column', @level2name = N'PARCEL_STATUS'
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'PARCEL_CLASS is the Parcel classification for maintenance, mapping, publishing and analysis, i.e., PRIMARY, SUBDIVISION, PART OF PRIMARY, BUILDING STRATA, BARE LAND STRATA, AIR SPACE, ROAD, HIGHWAY, PARK, INTEREST, COMMON OWNERSHIP, ABSOLUTE FEE BOOK, CRO' , 
	@level0type = N'Schema', @level0name = N'pmbc', 
	@level1type = N'Table', @level1name = N'PMBC_PARCEL_POLYGON_FABRIC', 
	@level2type = N'Column', @level2name = N'PARCEL_CLASS'
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'OWNER_TYPE is the general ownership category, e.g., PRIVATE, CROWN PROVINCIAL, MUNICIPAL.' , 
	@level0type = N'Schema', @level0name = N'pmbc', 
	@level1type = N'Table', @level1name = N'PMBC_PARCEL_POLYGON_FABRIC', 
	@level2type = N'Column', @level2name = N'OWNER_TYPE'
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'PARCEL_START_DATE is the date of the legal event that created the parcel, i.e., the date the plan was filed.' , 
	@level0type = N'Schema', @level0name = N'pmbc', 
	@level1type = N'Table', @level1name = N'PMBC_PARCEL_POLYGON_FABRIC', 
	@level2type = N'Column', @level2name = N'PARCEL_START_DATE'
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'SURVEY_DESIGNATION_1 is, typically, the smallest division of lands in a survey. If available, this is generally the Parcel from a Subdivided short legal description or the Quadrant or Block from an Unsubdivided short legal description, e.g., PARCEL A, SW4' , 
	@level0type = N'Schema', @level0name = N'pmbc', 
	@level1type = N'Table', @level1name = N'PMBC_PARCEL_POLYGON_FABRIC', 
	@level2type = N'Column', @level2name = N'SURVEY_DESIGNATION_1'
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'SURVEY_DESIGNATION_2 is, typically, the second smallest division of lands in a survey. If available, this is generally the Lot from a Subdivided short legal description or the District Lot, Lot or Section from an Unsubdivided short legal description, e.g.' , 
	@level0type = N'Schema', @level0name = N'pmbc', 
	@level1type = N'Table', @level1name = N'PMBC_PARCEL_POLYGON_FABRIC', 
	@level2type = N'Column', @level2name = N'SURVEY_DESIGNATION_2'
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'SURVEY_DESIGNATION_3 is, typically, the third smallest division of lands in a survey. If available, this is generally the Block from a Subdivided short legal description or the Range from an Unsubdivided short legal description, e.g., BLOCK H.' , 
	@level0type = N'Schema', @level0name = N'pmbc', 
	@level1type = N'Table', @level1name = N'PMBC_PARCEL_POLYGON_FABRIC', 
	@level2type = N'Column', @level2name = N'SURVEY_DESIGNATION_3'
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'LEGAL_DESCRIPTION is the full legal description of the parcel and is primarily recorded from the Land Title Register. Where recorded only in the Crown Land Registry, this attribute is to be populated from Tantalis for the fabric compilation, but maintaine' , 
	@level0type = N'Schema', @level0name = N'pmbc', 
	@level1type = N'Table', @level1name = N'PMBC_PARCEL_POLYGON_FABRIC', 
	@level2type = N'Column', @level2name = N'LEGAL_DESCRIPTION'
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'MUNICIPALITY is the municipal area within which the parcel is located. The value is either RURAL (for parcels in unincorporated regions) or the name of a BC municipality.' , 
	@level0type = N'Schema', @level0name = N'pmbc', 
	@level1type = N'Table', @level1name = N'PMBC_PARCEL_POLYGON_FABRIC', 
	@level2type = N'Column', @level2name = N'MUNICIPALITY'
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'REGIONAL_DISTRICT is the name of the regional district in which the parcel is located, e.g., CAPITAL REGIONAL DISTRICT.' , 
	@level0type = N'Schema', @level0name = N'pmbc', 
	@level1type = N'Table', @level1name = N'PMBC_PARCEL_POLYGON_FABRIC', 
	@level2type = N'Column', @level2name = N'REGIONAL_DISTRICT'
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'IS_REMAINDER_IND indicates if the parcel is a remainder of the original, i.e., YES, NO.' , 
	@level0type = N'Schema', @level0name = N'pmbc', 
	@level1type = N'Table', @level1name = N'PMBC_PARCEL_POLYGON_FABRIC', 
	@level2type = N'Column', @level2name = N'IS_REMAINDER_IND'
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'GEOMETRY_SOURCE is the source of the parcel geometry data, e.g., ICIS CADASTRE, ICF, PMBC OPERATIONS.' , 
	@level0type = N'Schema', @level0name = N'pmbc', 
	@level1type = N'Table', @level1name = N'PMBC_PARCEL_POLYGON_FABRIC', 
	@level2type = N'Column', @level2name = N'GEOMETRY_SOURCE'
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'POSITIONAL_ERROR is the semi-major axis at the 95% confidence level of the least accurate point of the parcel.' , 
	@level0type = N'Schema', @level0name = N'pmbc', 
	@level1type = N'Table', @level1name = N'PMBC_PARCEL_POLYGON_FABRIC', 
	@level2type = N'Column', @level2name = N'POSITIONAL_ERROR'
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'ERROR_REPORTED_BY is the organization or process reporting the error, i.e., LSA, DATA COMPILATION.' , 
	@level0type = N'Schema', @level0name = N'pmbc', 
	@level1type = N'Table', @level1name = N'PMBC_PARCEL_POLYGON_FABRIC', 
	@level2type = N'Column', @level2name = N'ERROR_REPORTED_BY'
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'CAPTURE_METHOD is an indicator of relative accuracy, i.e., UNKNOWN, COGO, SURVEY PLAN DATASET.' , 
	@level0type = N'Schema', @level0name = N'pmbc', 
	@level1type = N'Table', @level1name = N'PMBC_PARCEL_POLYGON_FABRIC', 
	@level2type = N'Column', @level2name = N'CAPTURE_METHOD'
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'COMPILED_IND indicates if the parcel polygon was generated from inverted dimensions, i.e., True, False. "True" means that the parcel geometry was from a previous source cadastre and not precision input based on plan dimensions.' , 
	@level0type = N'Schema', @level0name = N'pmbc', 
	@level1type = N'Table', @level1name = N'PMBC_PARCEL_POLYGON_FABRIC', 
	@level2type = N'Column', @level2name = N'COMPILED_IND'
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'STATED_AREA is the area of the parcel, in square metres. It is automatically calculated if misclose is small; it can be edited to reflect the recorded plan value.' , 
	@level0type = N'Schema', @level0name = N'pmbc', 
	@level1type = N'Table', @level1name = N'PMBC_PARCEL_POLYGON_FABRIC', 
	@level2type = N'Column', @level2name = N'STATED_AREA'
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'WHEN_CREATED is the date and time the source record was created (not the time when it was loaded into the BC Geographic Warehouse).' , 
	@level0type = N'Schema', @level0name = N'pmbc', 
	@level1type = N'Table', @level1name = N'PMBC_PARCEL_POLYGON_FABRIC', 
	@level2type = N'Column', @level2name = N'WHEN_CREATED'
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'WHEN_UPDATED is the date and time the source record was last modified (not the time when it was loaded into, or modified in, the BC Geographic Warehouse).' , 
	@level0type = N'Schema', @level0name = N'pmbc', 
	@level1type = N'Table', @level1name = N'PMBC_PARCEL_POLYGON_FABRIC', 
	@level2type = N'Column', @level2name = N'WHEN_UPDATED'
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'FEATURE_AREA_SQM is the system calculated area of a two-dimensional polygon in square meters.' , 
	@level0type = N'Schema', @level0name = N'pmbc', 
	@level1type = N'Table', @level1name = N'PMBC_PARCEL_POLYGON_FABRIC', 
	@level2type = N'Column', @level2name = N'FEATURE_AREA_SQM'
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'FEATURE_LENGTH_M is the system calculated length or perimeter of a geometry in meters.' , 
	@level0type = N'Schema', @level0name = N'pmbc', 
	@level1type = N'Table', @level1name = N'PMBC_PARCEL_POLYGON_FABRIC', 
	@level2type = N'Column', @level2name = N'FEATURE_LENGTH_M'
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'SHAPE is the column used to reference the spatial coordinates defining the feature.' , 
	@level0type = N'Schema', @level0name = N'pmbc', 
	@level1type = N'Table', @level1name = N'PMBC_PARCEL_POLYGON_FABRIC', 
	@level2type = N'Column', @level2name = N'SHAPE'
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'OBJECTID is a column required by spatial layers that interact with ESRI ArcSDE. It is populated with unique values automatically by SDE.' , 
	@level0type = N'Schema', @level0name = N'pmbc', 
	@level1type = N'Table', @level1name = N'PMBC_PARCEL_POLYGON_FABRIC', 
	@level2type = N'Column', @level2name = N'OBJECTID'
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'SE_ANNO_CAD_DATA is a binary column used by spatial tools to store annotation, curve features and CAD data when using the SDO_GEOMETRY storage data type.' , 
	@level0type = N'Schema', @level0name = N'pmbc', 
	@level1type = N'Table', @level1name = N'PMBC_PARCEL_POLYGON_FABRIC', 
	@level2type = N'Column', @level2name = N'SE_ANNO_CAD_DATA'
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'The ParcelMap BC (PMBC) parcel fabric contains all active titled parcels and surveyed provincial Crown land parcels in BC. For building strata parcels, there is a record, with PID value, for each parcel within the strata parcel; the geometry for those rec' , 
	@level0type = N'Schema', @level0name = N'pmbc', 
	@level1type = N'Table', @level1name = N'PMBC_PARCEL_POLYGON_FABRIC'
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create procedure dbo.pims_error_handling
PRINT N'Create procedure dbo.pims_error_handling'
GO
/* ---------------------------------------------------------------------- */
/* Add procedures                                                         */
/* ---------------------------------------------------------------------- */

-- ............................................................................................


-- --------------------------------------------------------------------------------------------
-- Create procedure [dbo].[pims_error_handling]
-- --------------------------------------------------------------------------------------------
CREATE PROCEDURE [dbo].[pims_error_handling] AS
  begin
    DECLARE @errmsg   nvarchar(2048),
      @severity tinyint,
      @state    tinyint,
      @errno    int,
      @proc     sysname,
      @lineno   int

    SELECT @errmsg = error_message(), @severity = error_severity(),
      @state  = error_state(), @errno = error_number(),
      @proc   = error_procedure(), @lineno = error_line()

    IF @errmsg NOT LIKE '***%'
      BEGIN
        SELECT @errmsg = '*** ' + coalesce(quotename(@proc), '<dynamic SQL>') +
          ', Line ' + ltrim(str(@lineno)) + '. Errno ' +
          ltrim(str(@errno)) + ': ' + @errmsg
      END

    RAISERROR('%s', @severity, @state, @errmsg)
  end
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create sequence dbo.PIMS_LEASE_TERM_H_ID_SEQ
PRINT N'Create sequence dbo.PIMS_LEASE_TERM_H_ID_SEQ'
GO
CREATE SEQUENCE [dbo].[PIMS_LEASE_TERM_H_ID_SEQ]
	AS bigint
	START WITH 1
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	NO CYCLE
	CACHE 50
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create table dbo.PIMS_LEASE_TERM_HIST
PRINT N'Create table dbo.PIMS_LEASE_TERM_HIST'
GO
CREATE TABLE [dbo].[PIMS_LEASE_TERM_HIST]  ( 
	[_LEASE_TERM_HIST_ID]           	bigint NOT NULL DEFAULT (NEXT VALUE FOR [PIMS_LEASE_TERM_H_ID_SEQ]),
	[EFFECTIVE_DATE_HIST]           	datetime NOT NULL DEFAULT (getutcdate()),
	[END_DATE_HIST]                 	datetime NULL,
	[LEASE_TERM_ID]                 	varchar(40) NOT NULL,
	[LEASE_ID]                      	bigint NOT NULL,
	[LEASE_TERM_STATUS_TYPE_CODE]   	nvarchar(20) NOT NULL,
	[TERM_START_DATE]               	datetime NOT NULL,
	[TERM_EXPIRY_DATE]              	datetime NULL,
	[TERM_RENEWAL_DATE]             	datetime NULL,
	[CONCURRENCY_CONTROL_NUMBER]    	bigint NOT NULL,
	[APP_CREATE_TIMESTAMP]          	datetime NOT NULL,
	[APP_CREATE_USERID]             	nvarchar(30) NOT NULL,
	[APP_CREATE_USER_GUID]          	uniqueidentifier NULL,
	[APP_CREATE_USER_DIRECTORY]     	nvarchar(30) NOT NULL,
	[APP_LAST_UPDATE_TIMESTAMP]     	datetime NOT NULL,
	[APP_LAST_UPDATE_USERID]        	nvarchar(30) NOT NULL,
	[APP_LAST_UPDATE_USER_GUID]     	uniqueidentifier NULL,
	[APP_LAST_UPDATE_USER_DIRECTORY]	nvarchar(30) NOT NULL,
	[DB_CREATE_TIMESTAMP]           	datetime NOT NULL,
	[DB_CREATE_USERID]              	nvarchar(30) NOT NULL,
	[DB_LAST_UPDATE_TIMESTAMP]      	datetime NOT NULL,
	[DB_LAST_UPDATE_USERID]         	nvarchar(30) NOT NULL,
	PRIMARY KEY CLUSTERED([_LEASE_TERM_HIST_ID])
 ON [PRIMARY])
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create unique constraint PIMS_LSTERM_H_UK
PRINT N'Create unique constraint PIMS_LSTERM_H_UK'
GO
ALTER TABLE [dbo].[PIMS_LEASE_TERM_HIST]
	ADD UNIQUE ([_LEASE_TERM_HIST_ID], [END_DATE_HIST]) 
	WITH (
		DATA_COMPRESSION = NONE
	) ON [PRIMARY]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Alter table dbo.PIMS_ADDRESS_HIST
PRINT N'Alter table dbo.PIMS_ADDRESS_HIST'
GO
ALTER TABLE [dbo].[PIMS_ADDRESS_HIST]
	ADD [COMMENT] nvarchar(2000) NULL
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Alter table dbo.PIMS_ORGANIZATION
PRINT N'Alter table dbo.PIMS_ORGANIZATION'
GO
ALTER TABLE [dbo].[PIMS_ORGANIZATION]
	ADD [ORGANIZATION_ALIAS] nvarchar(200) NULL
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Alter table dbo.PIMS_LEASE_TENANT
PRINT N'Alter table dbo.PIMS_LEASE_TENANT'
GO
ALTER TABLE [dbo].[PIMS_LEASE_TENANT]
	ADD [NOTE] nvarchar(2000) NULL
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Alter table dbo.PIMS_LEASE_TENANT_HIST
PRINT N'Alter table dbo.PIMS_LEASE_TENANT_HIST'
GO
ALTER TABLE [dbo].[PIMS_LEASE_TENANT_HIST]
	ADD [NOTE] nvarchar(2000) NULL
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create sequence dbo.PIMS_LEASE_PAYMENT_H_ID_SEQ
PRINT N'Create sequence dbo.PIMS_LEASE_PAYMENT_H_ID_SEQ'
GO
CREATE SEQUENCE [dbo].[PIMS_LEASE_PAYMENT_H_ID_SEQ]
	AS bigint
	START WITH 1
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	NO CYCLE
	CACHE 50
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create table dbo.PIMS_LEASE_PAYMENT_HIST
PRINT N'Create table dbo.PIMS_LEASE_PAYMENT_HIST'
GO
CREATE TABLE [dbo].[PIMS_LEASE_PAYMENT_HIST]  ( 
	[_LEASE_PAYMENT_HIST_ID]        	bigint NOT NULL DEFAULT (NEXT VALUE FOR [PIMS_LEASE_PAYMENT_H_ID_SEQ]),
	[EFFECTIVE_DATE_HIST]           	datetime NOT NULL DEFAULT (getutcdate()),
	[END_DATE_HIST]                 	datetime NULL,
	[LEASE_PAYMENT_ID]              	bigint NOT NULL,
	[LEASE_TERM_ID]                 	varchar(40) NOT NULL,
	[LEASE_PAYMENT_PERIOD_ID]       	bigint NOT NULL,
	[LEASE_PAYMENT_METHOD_TYPE_CODE]	nvarchar(20) NOT NULL,
	[PAYMENT_RECEIVED_DATE]         	datetime NOT NULL,
	[PAYMENT_AMOUNT_PRE_TAX]        	money NOT NULL,
	[PAYMENT_AMOUNT_PST]            	money NOT NULL,
	[PAYMENT_AMOUNT_GST]            	money NOT NULL,
	[PAYMENT_AMOUNT_TOTAL]          	money NOT NULL,
	[NOTE]                          	nvarchar(2000) NULL,
	[CONCURRENCY_CONTROL_NUMBER]    	bigint NOT NULL,
	[APP_CREATE_TIMESTAMP]          	datetime NOT NULL,
	[APP_CREATE_USERID]             	nvarchar(30) NOT NULL,
	[APP_CREATE_USER_GUID]          	uniqueidentifier NULL,
	[APP_CREATE_USER_DIRECTORY]     	nvarchar(30) NOT NULL,
	[APP_LAST_UPDATE_TIMESTAMP]     	datetime NOT NULL,
	[APP_LAST_UPDATE_USERID]        	nvarchar(30) NOT NULL,
	[APP_LAST_UPDATE_USER_GUID]     	uniqueidentifier NULL,
	[APP_LAST_UPDATE_USER_DIRECTORY]	nvarchar(30) NOT NULL,
	[DB_CREATE_TIMESTAMP]           	datetime NOT NULL,
	[DB_CREATE_USERID]              	nvarchar(30) NOT NULL,
	[DB_LAST_UPDATE_TIMESTAMP]      	datetime NOT NULL,
	[DB_LAST_UPDATE_USERID]         	nvarchar(30) NOT NULL,
	PRIMARY KEY CLUSTERED([_LEASE_PAYMENT_HIST_ID])
 ON [PRIMARY])
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create unique constraint PIMS_LSPYMT_H_UK
PRINT N'Create unique constraint PIMS_LSPYMT_H_UK'
GO
ALTER TABLE [dbo].[PIMS_LEASE_PAYMENT_HIST]
	ADD UNIQUE ([_LEASE_PAYMENT_HIST_ID], [END_DATE_HIST]) 
	WITH (
		DATA_COMPRESSION = NONE
	) ON [PRIMARY]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create sequence dbo.PIMS_LEASE_PAYMENT_FORECAST_H_ID_SEQ
PRINT N'Create sequence dbo.PIMS_LEASE_PAYMENT_FORECAST_H_ID_SEQ'
GO
CREATE SEQUENCE [dbo].[PIMS_LEASE_PAYMENT_FORECAST_H_ID_SEQ]
	AS bigint
	START WITH 1
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	NO CYCLE
	CACHE 50
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create table dbo.PIMS_LEASE_PAYMENT_FORECAST_HIST
PRINT N'Create table dbo.PIMS_LEASE_PAYMENT_FORECAST_HIST'
GO
CREATE TABLE [dbo].[PIMS_LEASE_PAYMENT_FORECAST_HIST]  ( 
	[_LEASE_PAYMENT_FORECAST_HIST_ID]	bigint NOT NULL DEFAULT (NEXT VALUE FOR [PIMS_LEASE_PAYMENT_FORECAST_H_ID_SEQ]),
	[EFFECTIVE_DATE_HIST]            	datetime NOT NULL DEFAULT (getutcdate()),
	[END_DATE_HIST]                  	datetime NULL,
	[LEASE_PAYMENT_FORECAST_ID]      	bigint NOT NULL,
	[LEASE_TERM_ID]                  	varchar(40) NOT NULL,
	[LEASE_PAYMENT_PERIOD_ID]        	bigint NOT NULL,
	[LEASE_PAYMENT_STATUS_TYPE_CODE] 	nvarchar(20) NOT NULL,
	[PAYMENT_DUE_DATE]               	datetime NOT NULL,
	[FORECAST_PAYMENT_PRE_TAX]       	money NOT NULL,
	[FORECAST_PAYMENT_PST]           	money NOT NULL,
	[FORECAST_PAYMENT_GST]           	money NOT NULL,
	[FORECAST_PAYMENT_TOTAL]         	money NOT NULL,
	[CONCURRENCY_CONTROL_NUMBER]     	bigint NOT NULL,
	[APP_CREATE_TIMESTAMP]           	datetime NOT NULL,
	[APP_CREATE_USERID]              	nvarchar(30) NOT NULL,
	[APP_CREATE_USER_GUID]           	uniqueidentifier NULL,
	[APP_CREATE_USER_DIRECTORY]      	nvarchar(30) NOT NULL,
	[APP_LAST_UPDATE_TIMESTAMP]      	datetime NOT NULL,
	[APP_LAST_UPDATE_USERID]         	nvarchar(30) NOT NULL,
	[APP_LAST_UPDATE_USER_GUID]      	uniqueidentifier NULL,
	[APP_LAST_UPDATE_USER_DIRECTORY] 	nvarchar(30) NOT NULL,
	[DB_CREATE_TIMESTAMP]            	datetime NOT NULL,
	[DB_CREATE_USERID]               	nvarchar(30) NOT NULL,
	[DB_LAST_UPDATE_TIMESTAMP]       	datetime NOT NULL,
	[DB_LAST_UPDATE_USERID]          	nvarchar(30) NOT NULL,
	PRIMARY KEY CLUSTERED([_LEASE_PAYMENT_FORECAST_HIST_ID])
 ON [PRIMARY])
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create unique constraint PIMS_LPFCST_H_UK
PRINT N'Create unique constraint PIMS_LPFCST_H_UK'
GO
ALTER TABLE [dbo].[PIMS_LEASE_PAYMENT_FORECAST_HIST]
	ADD UNIQUE ([_LEASE_PAYMENT_FORECAST_HIST_ID], [END_DATE_HIST]) 
	WITH (
		DATA_COMPRESSION = NONE
	) ON [PRIMARY]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Alter table dbo.PIMS_PROPERTY_IMPROVEMENT
PRINT N'Alter table dbo.PIMS_PROPERTY_IMPROVEMENT'
GO
ALTER TABLE [dbo].[PIMS_PROPERTY_IMPROVEMENT] ALTER COLUMN [STRUCTURE_SIZE] nvarchar(2000) NULL
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO
ALTER TABLE [dbo].[PIMS_PROPERTY_IMPROVEMENT]
	ADD [UNIT] nvarchar(2000) NULL
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'Unit(s) affected' , 
	@level0type = N'Schema', @level0name = N'dbo', 
	@level1type = N'Table', @level1name = N'PIMS_PROPERTY_IMPROVEMENT', 
	@level2type = N'Column', @level2name = N'UNIT'
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO
ALTER TABLE [dbo].[PIMS_PROPERTY_IMPROVEMENT]
	DROP COLUMN [PROPERTY_IMPROVEMENT_UOM_TYPE_CODE]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create sequence dbo.PIMS_LEASE_PAYMENT_PERIOD_H_ID_SEQ
PRINT N'Create sequence dbo.PIMS_LEASE_PAYMENT_PERIOD_H_ID_SEQ'
GO
CREATE SEQUENCE [dbo].[PIMS_LEASE_PAYMENT_PERIOD_H_ID_SEQ]
	AS bigint
	START WITH 1
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	NO CYCLE
	CACHE 50
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create table dbo.PIMS_LEASE_PAYMENT_PERIOD_HIST
PRINT N'Create table dbo.PIMS_LEASE_PAYMENT_PERIOD_HIST'
GO
CREATE TABLE [dbo].[PIMS_LEASE_PAYMENT_PERIOD_HIST]  ( 
	[_LEASE_PAYMENT_PERIOD_HIST_ID] 	bigint NOT NULL DEFAULT (NEXT VALUE FOR [PIMS_LEASE_PAYMENT_PERIOD_H_ID_SEQ]),
	[EFFECTIVE_DATE_HIST]           	datetime NOT NULL DEFAULT (getutcdate()),
	[END_DATE_HIST]                 	datetime NULL,
	[LEASE_PAYMENT_PERIOD_ID]       	bigint NOT NULL,
	[PERIOD_START_DATE]             	date NOT NULL,
	[IS_PERIOD_CLOSED]              	bit NOT NULL,
	[CONCURRENCY_CONTROL_NUMBER]    	bigint NOT NULL,
	[APP_CREATE_TIMESTAMP]          	datetime NOT NULL,
	[APP_CREATE_USERID]             	nvarchar(30) NOT NULL,
	[APP_CREATE_USER_GUID]          	uniqueidentifier NULL,
	[APP_CREATE_USER_DIRECTORY]     	nvarchar(30) NOT NULL,
	[APP_LAST_UPDATE_TIMESTAMP]     	datetime NOT NULL,
	[APP_LAST_UPDATE_USERID]        	nvarchar(30) NOT NULL,
	[APP_LAST_UPDATE_USER_GUID]     	uniqueidentifier NULL,
	[APP_LAST_UPDATE_USER_DIRECTORY]	nvarchar(30) NOT NULL,
	[DB_CREATE_TIMESTAMP]           	datetime NOT NULL,
	[DB_CREATE_USERID]              	nvarchar(30) NOT NULL,
	[DB_LAST_UPDATE_TIMESTAMP]      	datetime NOT NULL,
	[DB_LAST_UPDATE_USERID]         	nvarchar(30) NOT NULL,
	PRIMARY KEY CLUSTERED([_LEASE_PAYMENT_PERIOD_HIST_ID])
 ON [PRIMARY])
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create unique constraint PIMS_LPYPER_H_UK
PRINT N'Create unique constraint PIMS_LPYPER_H_UK'
GO
ALTER TABLE [dbo].[PIMS_LEASE_PAYMENT_PERIOD_HIST]
	ADD UNIQUE ([_LEASE_PAYMENT_PERIOD_HIST_ID], [END_DATE_HIST]) 
	WITH (
		DATA_COMPRESSION = NONE
	) ON [PRIMARY]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Alter table dbo.PIMS_PERSON_HIST
PRINT N'Alter table dbo.PIMS_PERSON_HIST'
GO
ALTER TABLE [dbo].[PIMS_PERSON_HIST]
	ADD [PREFERRED_NAME] nvarchar(200) NULL
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Alter table dbo.PIMS_ORGANIZATION_HIST
PRINT N'Alter table dbo.PIMS_ORGANIZATION_HIST'
GO
ALTER TABLE [dbo].[PIMS_ORGANIZATION_HIST]
	ADD [ORGANIZATION_ALIAS] nvarchar(200) NULL
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Alter table dbo.PIMS_LEASE_HIST
PRINT N'Alter table dbo.PIMS_LEASE_HIST'
GO
ALTER TABLE [dbo].[PIMS_LEASE_HIST] ALTER COLUMN [RENEWAL_COUNT] smallint NULL
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO
ALTER TABLE [dbo].[PIMS_LEASE_HIST] ADD DEFAULT ((0)) FOR [RENEWAL_TERM_MONTHS]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO
EXEC sp_addextendedproperty 
	@name = N'MS_Description', @value = N'Number of months included in lease renewal' , 
	@level0type = N'Schema', @level0name = N'dbo', 
	@level1type = N'Table', @level1name = N'PIMS_LEASE_HIST', 
	@level2type = N'Column', @level2name = N'RENEWAL_TERM_MONTHS'
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO
ALTER TABLE [dbo].[PIMS_LEASE_HIST]
	ADD [LEASE_INITIATOR_TYPE_CODE] nvarchar(20) NOT NULL, 
	[LEASE_RESPONSIBILITY_TYPE_CODE] nvarchar(20) NOT NULL, 
	[RESPONSIBILITY_EFFECTIVE_DATE] datetime NULL, 
	[IS_SUBJECT_TO_RTA] bit NULL, 
	[IS_COMM_BLDG] bit NULL, 
	[IS_OTHER_IMPROVEMENT] bit NULL
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO
ALTER TABLE [dbo].[PIMS_LEASE_HIST]
	DROP COLUMN [TERM_START_DATE], [TERM_EXPIRY_DATE], [TERM_RENEWAL_DATE]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Alter table dbo.PIMS_PROPERTY_IMPROVEMENT_HIST
PRINT N'Alter table dbo.PIMS_PROPERTY_IMPROVEMENT_HIST'
GO
ALTER TABLE [dbo].[PIMS_PROPERTY_IMPROVEMENT_HIST] ALTER COLUMN [STRUCTURE_SIZE] nvarchar(2000) NULL
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO
ALTER TABLE [dbo].[PIMS_PROPERTY_IMPROVEMENT_HIST]
	ADD [UNIT] nvarchar(2000) NULL
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO
ALTER TABLE [dbo].[PIMS_PROPERTY_IMPROVEMENT_HIST]
	DROP COLUMN [PROPERTY_IMPROVEMENT_UOM_TYPE_CODE]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create view dbo.PIMS_PROPERTY_LOCATION_VW
PRINT N'Create view dbo.PIMS_PROPERTY_LOCATION_VW'
GO
CREATE VIEW [dbo].[PIMS_PROPERTY_LOCATION_VW] AS
SELECT PROP.PROPERTY_ID              
     , PROP.PID
     , RIGHT('000000000' + CAST(PROP.PID AS VARCHAR(9)), 9) AS PID_PADDED
     , PROP.PIN                   
     , PROP.PROPERTY_TYPE_CODE
     , PROP.PROPERTY_STATUS_TYPE_CODE
     , PROP.PROPERTY_DATA_SOURCE_TYPE_CODE
     , PROP.PROPERTY_DATA_SOURCE_EFFECTIVE_DATE
     , PROP.PROPERTY_CLASSIFICATION_TYPE_CODE
     , PROP.PROPERTY_TENURE_TYPE_CODE
     , ADDR.STREET_ADDRESS_1
     , ADDR.STREET_ADDRESS_2
     , ADDR.STREET_ADDRESS_3
     , ADDR.MUNICIPALITY_NAME
     , ADDR.POSTAL_CODE      
     , PROV.PROVINCE_STATE_CODE
     , PROV.DESCRIPTION AS PROVINCE_NAME
     , CNTY.COUNTRY_CODE
     , CNTY.DESCRIPTION AS COUNTRY_NAME
     , PROP.NAME
     , PROP.DESCRIPTION
     , PROP.ADDRESS_ID                 
     , PROP.REGION_CODE
     , PROP.DISTRICT_CODE
     , PROP.LOCATION AS GEOMETRY
     , PROP.PROPERTY_AREA_UNIT_TYPE_CODE
     , PROP.LAND_AREA
     , PROP.LAND_LEGAL_DESCRIPTION
     , PROP.ENCUMBRANCE_REASON                                      
     , PROP.IS_SENSITIVE
     , PROP.IS_OWNED
     , PROP.IS_PROPERTY_OF_INTEREST
     , PROP.IS_VISIBLE_TO_OTHER_AGENCIES
     , PROP.ZONING,ZONING_POTENTIAL
FROM   PIMS_PROPERTY       PROP                                                    INNER JOIN
       PIMS_ADDRESS        ADDR ON ADDR.ADDRESS_ID        = PROP.ADDRESS_ID        INNER JOIN
       PIMS_PROVINCE_STATE PROV ON PROV.PROVINCE_STATE_ID = ADDR.PROVINCE_STATE_ID INNER JOIN
       PIMS_COUNTRY        CNTY ON CNTY.COUNTRY_ID        = ADDR.COUNTRY_ID
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create view dbo.PIMS_PROPERTY_BOUNDARY_VW
PRINT N'Create view dbo.PIMS_PROPERTY_BOUNDARY_VW'
GO
/* ---------------------------------------------------------------------- */
/* Add views                                                              */
/* ---------------------------------------------------------------------- */

/* ---------------------------------------------------------------------- */
/* Add views                                                              */
/* ---------------------------------------------------------------------- */

CREATE VIEW [dbo].[PIMS_PROPERTY_BOUNDARY_VW] AS
SELECT PROP.PROPERTY_ID
     , PROP.PID
     , RIGHT('000000000' + CAST(PROP.PID AS VARCHAR(9)), 9) AS PID_PADDED
     , PROP.PIN
     , PROP.PROPERTY_TYPE_CODE
     , PROP.PROPERTY_STATUS_TYPE_CODE
     , PROP.PROPERTY_DATA_SOURCE_TYPE_CODE
     , PROP.PROPERTY_DATA_SOURCE_EFFECTIVE_DATE
     , PROP.PROPERTY_CLASSIFICATION_TYPE_CODE
     , PROP.PROPERTY_TENURE_TYPE_CODE
     , ADDR.STREET_ADDRESS_1
     , ADDR.STREET_ADDRESS_2
     , ADDR.STREET_ADDRESS_3
     , ADDR.MUNICIPALITY_NAME
     , ADDR.POSTAL_CODE
     , PROV.PROVINCE_STATE_CODE
     , PROV.DESCRIPTION AS PROVINCE_NAME
     , CNTY.COUNTRY_CODE
     , CNTY.DESCRIPTION AS COUNTRY_NAME
     , PROP.NAME
     , PROP.DESCRIPTION
     , PROP.ADDRESS_ID
     , PROP.REGION_CODE
     , PROP.DISTRICT_CODE
     , PROP.BOUNDARY AS GEOMETRY
     , PROP.PROPERTY_AREA_UNIT_TYPE_CODE
     , PROP.LAND_AREA
     , PROP.LAND_LEGAL_DESCRIPTION
     , PROP.ENCUMBRANCE_REASON
     , PROP.IS_SENSITIVE
     , PROP.IS_OWNED
     , PROP.IS_PROPERTY_OF_INTEREST
     , PROP.IS_VISIBLE_TO_OTHER_AGENCIES
     , PROP.ZONING,ZONING_POTENTIAL
FROM   PIMS_PROPERTY       PROP                                                    INNER JOIN
       PIMS_ADDRESS        ADDR ON ADDR.ADDRESS_ID        = PROP.ADDRESS_ID        INNER JOIN
       PIMS_PROVINCE_STATE PROV ON PROV.PROVINCE_STATE_ID = ADDR.PROVINCE_STATE_ID INNER JOIN
       PIMS_COUNTRY        CNTY ON CNTY.COUNTRY_ID        = ADDR.COUNTRY_ID
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create index dbo.LSTERM_LEASE_TERM_STATUS_TYPE_CODE_IDX
PRINT N'Create index dbo.LSTERM_LEASE_TERM_STATUS_TYPE_CODE_IDX'
GO
CREATE NONCLUSTERED INDEX [LSTERM_LEASE_TERM_STATUS_TYPE_CODE_IDX]
	ON [dbo].[PIMS_LEASE_TERM]([LEASE_TERM_STATUS_TYPE_CODE])
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create index dbo.LPFCST_LEASE_TERM_ID_IDX
PRINT N'Create index dbo.LPFCST_LEASE_TERM_ID_IDX'
GO
CREATE NONCLUSTERED INDEX [LPFCST_LEASE_TERM_ID_IDX]
	ON [dbo].[PIMS_LEASE_PAYMENT_FORECAST]([LEASE_TERM_ID])
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create index dbo.LSPYMT_LEASE_PAYMENT_METHOD_TYPE_CODE_IDX
PRINT N'Create index dbo.LSPYMT_LEASE_PAYMENT_METHOD_TYPE_CODE_IDX'
GO
CREATE NONCLUSTERED INDEX [LSPYMT_LEASE_PAYMENT_METHOD_TYPE_CODE_IDX]
	ON [dbo].[PIMS_LEASE_PAYMENT]([LEASE_PAYMENT_METHOD_TYPE_CODE])
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create index dbo.LEASE_LEASE_RESPONSIBILITY_TYPE_CODE_IDX
PRINT N'Create index dbo.LEASE_LEASE_RESPONSIBILITY_TYPE_CODE_IDX'
GO
CREATE NONCLUSTERED INDEX [LEASE_LEASE_RESPONSIBILITY_TYPE_CODE_IDX]
	ON [dbo].[PIMS_LEASE]([LEASE_RESPONSIBILITY_TYPE_CODE])
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create index dbo.LSPYMT_LEASE_TERM_ID_IDX
PRINT N'Create index dbo.LSPYMT_LEASE_TERM_ID_IDX'
GO
CREATE NONCLUSTERED INDEX [LSPYMT_LEASE_TERM_ID_IDX]
	ON [dbo].[PIMS_LEASE_PAYMENT]([LEASE_TERM_ID])
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create index dbo.LEASE_LEASE_INITIATOR_TYPE_CODE_IDX
PRINT N'Create index dbo.LEASE_LEASE_INITIATOR_TYPE_CODE_IDX'
GO
CREATE NONCLUSTERED INDEX [LEASE_LEASE_INITIATOR_TYPE_CODE_IDX]
	ON [dbo].[PIMS_LEASE]([LEASE_INITIATOR_TYPE_CODE])
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create index pmbc.PRCPLY_PID_NUMBER_IDX
PRINT N'Create index pmbc.PRCPLY_PID_NUMBER_IDX'
GO
CREATE NONCLUSTERED INDEX [PRCPLY_PID_NUMBER_IDX]
	ON [pmbc].[PMBC_PARCEL_POLYGON_FABRIC]([PID_NUMBER])
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create index dbo.LPFCST_LEASE_PAYMENT_PERIOD_ID_IDX
PRINT N'Create index dbo.LPFCST_LEASE_PAYMENT_PERIOD_ID_IDX'
GO
CREATE NONCLUSTERED INDEX [LPFCST_LEASE_PAYMENT_PERIOD_ID_IDX]
	ON [dbo].[PIMS_LEASE_PAYMENT_FORECAST]([LEASE_PAYMENT_PERIOD_ID])
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create index dbo.LPFCST_LEASE_PAYMENT_STATUS_TYPE_CODE_IDX
PRINT N'Create index dbo.LPFCST_LEASE_PAYMENT_STATUS_TYPE_CODE_IDX'
GO
CREATE NONCLUSTERED INDEX [LPFCST_LEASE_PAYMENT_STATUS_TYPE_CODE_IDX]
	ON [dbo].[PIMS_LEASE_PAYMENT_FORECAST]([LEASE_PAYMENT_STATUS_TYPE_CODE])
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create index dbo.LSTERM_LEASE_ID_IDX
PRINT N'Create index dbo.LSTERM_LEASE_ID_IDX'
GO
CREATE NONCLUSTERED INDEX [LSTERM_LEASE_ID_IDX]
	ON [dbo].[PIMS_LEASE_TERM]([LEASE_ID])
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create index dbo.LSPYMT_LEASE_PAYMENT_PERIOD_ID_IDX
PRINT N'Create index dbo.LSPYMT_LEASE_PAYMENT_PERIOD_ID_IDX'
GO
CREATE NONCLUSTERED INDEX [LSPYMT_LEASE_PAYMENT_PERIOD_ID_IDX]
	ON [dbo].[PIMS_LEASE_PAYMENT]([LEASE_PAYMENT_PERIOD_ID])
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger dbo.PIMS_PERSON_I_S_I_TR
PRINT N'Create trigger dbo.PIMS_PERSON_I_S_I_TR'
GO
CREATE TRIGGER [dbo].[PIMS_PERSON_I_S_I_TR] ON PIMS_PERSON INSTEAD OF INSERT AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM inserted)
    RETURN;


  insert into PIMS_PERSON ("PERSON_ID",
      "ADDRESS_ID",
      "SURNAME",
      "FIRST_NAME",
      "MIDDLE_NAMES",
      "NAME_SUFFIX",
      "PREFERRED_NAME",
      "BIRTH_DATE",
      "IS_DISABLED",
      "CONCURRENCY_CONTROL_NUMBER",
      "APP_CREATE_TIMESTAMP",
      "APP_CREATE_USERID",
      "APP_CREATE_USER_GUID",
      "APP_CREATE_USER_DIRECTORY",
      "APP_LAST_UPDATE_TIMESTAMP",
      "APP_LAST_UPDATE_USERID",
      "APP_LAST_UPDATE_USER_GUID",
      "APP_LAST_UPDATE_USER_DIRECTORY")
    select "PERSON_ID",
      "ADDRESS_ID",
      "SURNAME",
      "FIRST_NAME",
      "MIDDLE_NAMES",
      "NAME_SUFFIX",
      "PREFERRED_NAME",
      "BIRTH_DATE",
      "IS_DISABLED",
      "CONCURRENCY_CONTROL_NUMBER",
      "APP_CREATE_TIMESTAMP",
      "APP_CREATE_USERID",
      "APP_CREATE_USER_GUID",
      "APP_CREATE_USER_DIRECTORY",
      "APP_LAST_UPDATE_TIMESTAMP",
      "APP_LAST_UPDATE_USERID",
      "APP_LAST_UPDATE_USER_GUID",
      "APP_LAST_UPDATE_USER_DIRECTORY"
    from inserted;

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC pims_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger dbo.PIMS_LSTERM_I_S_I_TR
PRINT N'Create trigger dbo.PIMS_LSTERM_I_S_I_TR'
GO
CREATE TRIGGER [dbo].[PIMS_LSTERM_I_S_I_TR] ON PIMS_LEASE_TERM INSTEAD OF INSERT AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM inserted)
    RETURN;


  insert into PIMS_LEASE_TERM ("LEASE_TERM_ID",
      "LEASE_ID",
      "LEASE_TERM_STATUS_TYPE_CODE",
      "TERM_START_DATE",
      "TERM_EXPIRY_DATE",
      "TERM_RENEWAL_DATE",
      "CONCURRENCY_CONTROL_NUMBER",
      "APP_CREATE_TIMESTAMP",
      "APP_CREATE_USERID",
      "APP_CREATE_USER_GUID",
      "APP_CREATE_USER_DIRECTORY",
      "APP_LAST_UPDATE_TIMESTAMP",
      "APP_LAST_UPDATE_USERID",
      "APP_LAST_UPDATE_USER_GUID",
      "APP_LAST_UPDATE_USER_DIRECTORY")
    select "LEASE_TERM_ID",
      "LEASE_ID",
      "LEASE_TERM_STATUS_TYPE_CODE",
      "TERM_START_DATE",
      "TERM_EXPIRY_DATE",
      "TERM_RENEWAL_DATE",
      "CONCURRENCY_CONTROL_NUMBER",
      "APP_CREATE_TIMESTAMP",
      "APP_CREATE_USERID",
      "APP_CREATE_USER_GUID",
      "APP_CREATE_USER_DIRECTORY",
      "APP_LAST_UPDATE_TIMESTAMP",
      "APP_LAST_UPDATE_USERID",
      "APP_LAST_UPDATE_USER_GUID",
      "APP_LAST_UPDATE_USER_DIRECTORY"
    from inserted;

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC pims_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger dbo.PIMS_LPYPER_I_S_U_TR
PRINT N'Create trigger dbo.PIMS_LPYPER_I_S_U_TR'
GO
CREATE TRIGGER [dbo].[PIMS_LPYPER_I_S_U_TR] ON PIMS_LEASE_PAYMENT_PERIOD INSTEAD OF UPDATE AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM deleted)
    RETURN;

  -- validate concurrency control
  if exists (select 1 from inserted, deleted where inserted.CONCURRENCY_CONTROL_NUMBER != deleted.CONCURRENCY_CONTROL_NUMBER+1 AND inserted.LEASE_PAYMENT_PERIOD_ID = deleted.LEASE_PAYMENT_PERIOD_ID)
    raiserror('CONCURRENCY FAILURE.',16,1)


  -- update statement
  update PIMS_LEASE_PAYMENT_PERIOD
    set "LEASE_PAYMENT_PERIOD_ID" = inserted."LEASE_PAYMENT_PERIOD_ID",
      "PERIOD_START_DATE" = inserted."PERIOD_START_DATE",
      "IS_PERIOD_CLOSED" = inserted."IS_PERIOD_CLOSED",
      "CONCURRENCY_CONTROL_NUMBER" = inserted."CONCURRENCY_CONTROL_NUMBER",
      "APP_LAST_UPDATE_TIMESTAMP" = inserted."APP_LAST_UPDATE_TIMESTAMP",
      "APP_LAST_UPDATE_USERID" = inserted."APP_LAST_UPDATE_USERID",
      "APP_LAST_UPDATE_USER_GUID" = inserted."APP_LAST_UPDATE_USER_GUID",
      "APP_LAST_UPDATE_USER_DIRECTORY" = inserted."APP_LAST_UPDATE_USER_DIRECTORY"
    , DB_LAST_UPDATE_TIMESTAMP = getutcdate()
    , DB_LAST_UPDATE_USERID = user_name()
    from PIMS_LEASE_PAYMENT_PERIOD
    inner join inserted
    on (PIMS_LEASE_PAYMENT_PERIOD.LEASE_PAYMENT_PERIOD_ID = inserted.LEASE_PAYMENT_PERIOD_ID);

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC pims_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger dbo.PIMS_ADDRSS_I_S_I_TR
PRINT N'Create trigger dbo.PIMS_ADDRSS_I_S_I_TR'
GO
CREATE TRIGGER [dbo].[PIMS_ADDRSS_I_S_I_TR] ON PIMS_ADDRESS INSTEAD OF INSERT AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM inserted)
    RETURN;


  insert into PIMS_ADDRESS ("ADDRESS_ID",
      "ADDRESS_USAGE_TYPE_CODE",
      "REGION_CODE",
      "DISTRICT_CODE",
      "PROVINCE_STATE_ID",
      "COUNTRY_ID",
      "STREET_ADDRESS_1",
      "STREET_ADDRESS_2",
      "STREET_ADDRESS_3",
      "MUNICIPALITY_NAME",
      "POSTAL_CODE",
      "LATITUDE",
      "LONGITUDE",
      "COMMENT",
      "CONCURRENCY_CONTROL_NUMBER",
      "APP_CREATE_TIMESTAMP",
      "APP_CREATE_USERID",
      "APP_CREATE_USER_GUID",
      "APP_CREATE_USER_DIRECTORY",
      "APP_LAST_UPDATE_TIMESTAMP",
      "APP_LAST_UPDATE_USERID",
      "APP_LAST_UPDATE_USER_GUID",
      "APP_LAST_UPDATE_USER_DIRECTORY")
    select "ADDRESS_ID",
      "ADDRESS_USAGE_TYPE_CODE",
      "REGION_CODE",
      "DISTRICT_CODE",
      "PROVINCE_STATE_ID",
      "COUNTRY_ID",
      "STREET_ADDRESS_1",
      "STREET_ADDRESS_2",
      "STREET_ADDRESS_3",
      "MUNICIPALITY_NAME",
      "POSTAL_CODE",
      "LATITUDE",
      "LONGITUDE",
      "COMMENT",
      "CONCURRENCY_CONTROL_NUMBER",
      "APP_CREATE_TIMESTAMP",
      "APP_CREATE_USERID",
      "APP_CREATE_USER_GUID",
      "APP_CREATE_USER_DIRECTORY",
      "APP_LAST_UPDATE_TIMESTAMP",
      "APP_LAST_UPDATE_USERID",
      "APP_LAST_UPDATE_USER_GUID",
      "APP_LAST_UPDATE_USER_DIRECTORY"
    from inserted;

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC pims_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger dbo.PIMS_LINITT_I_S_U_TR
PRINT N'Create trigger dbo.PIMS_LINITT_I_S_U_TR'
GO
CREATE TRIGGER [dbo].[PIMS_LINITT_I_S_U_TR] ON PIMS_LEASE_INITIATOR_TYPE INSTEAD OF UPDATE AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM deleted)
    RETURN;

  -- validate concurrency control
  if exists (select 1 from inserted, deleted where inserted.CONCURRENCY_CONTROL_NUMBER != deleted.CONCURRENCY_CONTROL_NUMBER+1 AND inserted.LEASE_INITIATOR_TYPE_CODE = deleted.LEASE_INITIATOR_TYPE_CODE)
    raiserror('CONCURRENCY FAILURE.',16,1)


  -- update statement
  update PIMS_LEASE_INITIATOR_TYPE
    set "LEASE_INITIATOR_TYPE_CODE" = inserted."LEASE_INITIATOR_TYPE_CODE",
      "DESCRIPTION" = inserted."DESCRIPTION",
      "IS_DISABLED" = inserted."IS_DISABLED",
      "DISPLAY_ORDER" = inserted."DISPLAY_ORDER",
      "CONCURRENCY_CONTROL_NUMBER" = inserted."CONCURRENCY_CONTROL_NUMBER"
    , DB_LAST_UPDATE_TIMESTAMP = getutcdate()
    , DB_LAST_UPDATE_USERID = user_name()
    from PIMS_LEASE_INITIATOR_TYPE
    inner join inserted
    on (PIMS_LEASE_INITIATOR_TYPE.LEASE_INITIATOR_TYPE_CODE = inserted.LEASE_INITIATOR_TYPE_CODE);

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC pims_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger dbo.PIMS_LSTERM_I_S_U_TR
PRINT N'Create trigger dbo.PIMS_LSTERM_I_S_U_TR'
GO
CREATE TRIGGER [dbo].[PIMS_LSTERM_I_S_U_TR] ON PIMS_LEASE_TERM INSTEAD OF UPDATE AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM deleted)
    RETURN;

  -- validate concurrency control
  if exists (select 1 from inserted, deleted where inserted.CONCURRENCY_CONTROL_NUMBER != deleted.CONCURRENCY_CONTROL_NUMBER+1 AND inserted.LEASE_TERM_ID = deleted.LEASE_TERM_ID)
    raiserror('CONCURRENCY FAILURE.',16,1)


  -- update statement
  update PIMS_LEASE_TERM
    set "LEASE_TERM_ID" = inserted."LEASE_TERM_ID",
      "LEASE_ID" = inserted."LEASE_ID",
      "LEASE_TERM_STATUS_TYPE_CODE" = inserted."LEASE_TERM_STATUS_TYPE_CODE",
      "TERM_START_DATE" = inserted."TERM_START_DATE",
      "TERM_EXPIRY_DATE" = inserted."TERM_EXPIRY_DATE",
      "TERM_RENEWAL_DATE" = inserted."TERM_RENEWAL_DATE",
      "CONCURRENCY_CONTROL_NUMBER" = inserted."CONCURRENCY_CONTROL_NUMBER",
      "APP_LAST_UPDATE_TIMESTAMP" = inserted."APP_LAST_UPDATE_TIMESTAMP",
      "APP_LAST_UPDATE_USERID" = inserted."APP_LAST_UPDATE_USERID",
      "APP_LAST_UPDATE_USER_GUID" = inserted."APP_LAST_UPDATE_USER_GUID",
      "APP_LAST_UPDATE_USER_DIRECTORY" = inserted."APP_LAST_UPDATE_USER_DIRECTORY"
    , DB_LAST_UPDATE_TIMESTAMP = getutcdate()
    , DB_LAST_UPDATE_USERID = user_name()
    from PIMS_LEASE_TERM
    inner join inserted
    on (PIMS_LEASE_TERM.LEASE_TERM_ID = inserted.LEASE_TERM_ID);

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC pims_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger dbo.PIMS_LSTERM_A_S_IUD_TR
PRINT N'Create trigger dbo.PIMS_LSTERM_A_S_IUD_TR'
GO
CREATE TRIGGER [dbo].[PIMS_LSTERM_A_S_IUD_TR] ON PIMS_LEASE_TERM FOR INSERT, UPDATE, DELETE AS
SET NOCOUNT ON
BEGIN TRY
DECLARE @curr_date datetime;
SET @curr_date = getutcdate();
  IF NOT EXISTS(SELECT * FROM inserted) AND NOT EXISTS(SELECT * FROM deleted)
    RETURN;

  -- historical
  IF EXISTS(SELECT * FROM deleted)
    update PIMS_LEASE_TERM_HIST set END_DATE_HIST = @curr_date where LEASE_TERM_ID in (select LEASE_TERM_ID from deleted) and END_DATE_HIST is null;

  IF EXISTS(SELECT * FROM inserted)
    insert into PIMS_LEASE_TERM_HIST ([LEASE_TERM_ID], [LEASE_ID], [LEASE_TERM_STATUS_TYPE_CODE], [TERM_START_DATE], [TERM_EXPIRY_DATE], [TERM_RENEWAL_DATE], [CONCURRENCY_CONTROL_NUMBER], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [DB_CREATE_TIMESTAMP], [DB_CREATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], _LEASE_TERM_HIST_ID, END_DATE_HIST, EFFECTIVE_DATE_HIST)
      select [LEASE_TERM_ID], [LEASE_ID], [LEASE_TERM_STATUS_TYPE_CODE], [TERM_START_DATE], [TERM_EXPIRY_DATE], [TERM_RENEWAL_DATE], [CONCURRENCY_CONTROL_NUMBER], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [DB_CREATE_TIMESTAMP], [DB_CREATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], (next value for [dbo].[PIMS_LEASE_TERM_H_ID_SEQ]) as [_LEASE_TERM_HIST_ID], null as [END_DATE_HIST], @curr_date as [EFFECTIVE_DATE_HIST] from inserted;

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC pims_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger dbo.PIMS_ADDRSS_A_S_IUD_TR
PRINT N'Create trigger dbo.PIMS_ADDRSS_A_S_IUD_TR'
GO
CREATE TRIGGER [dbo].[PIMS_ADDRSS_A_S_IUD_TR] ON PIMS_ADDRESS FOR INSERT, UPDATE, DELETE AS
SET NOCOUNT ON
BEGIN TRY
DECLARE @curr_date datetime;
SET @curr_date = getutcdate();
  IF NOT EXISTS(SELECT * FROM inserted) AND NOT EXISTS(SELECT * FROM deleted)
    RETURN;

  -- historical
  IF EXISTS(SELECT * FROM deleted)
    update PIMS_ADDRESS_HIST set END_DATE_HIST = @curr_date where ADDRESS_ID in (select ADDRESS_ID from deleted) and END_DATE_HIST is null;

  IF EXISTS(SELECT * FROM inserted)
    insert into PIMS_ADDRESS_HIST ([ADDRESS_ID], [ADDRESS_USAGE_TYPE_CODE], [REGION_CODE], [DISTRICT_CODE], [PROVINCE_STATE_ID], [COUNTRY_ID], [STREET_ADDRESS_1], [STREET_ADDRESS_2], [STREET_ADDRESS_3], [MUNICIPALITY_NAME], [POSTAL_CODE], [LATITUDE], [LONGITUDE], [COMMENT], [CONCURRENCY_CONTROL_NUMBER], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [DB_CREATE_TIMESTAMP], [DB_CREATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], _ADDRESS_HIST_ID, END_DATE_HIST, EFFECTIVE_DATE_HIST)
      select [ADDRESS_ID], [ADDRESS_USAGE_TYPE_CODE], [REGION_CODE], [DISTRICT_CODE], [PROVINCE_STATE_ID], [COUNTRY_ID], [STREET_ADDRESS_1], [STREET_ADDRESS_2], [STREET_ADDRESS_3], [MUNICIPALITY_NAME], [POSTAL_CODE], [LATITUDE], [LONGITUDE], [COMMENT], [CONCURRENCY_CONTROL_NUMBER], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [DB_CREATE_TIMESTAMP], [DB_CREATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], (next value for [dbo].[PIMS_ADDRESS_H_ID_SEQ]) as [_ADDRESS_HIST_ID], null as [END_DATE_HIST], @curr_date as [EFFECTIVE_DATE_HIST] from inserted;

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC pims_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger dbo.PIMS_ADDRSS_I_S_U_TR
PRINT N'Create trigger dbo.PIMS_ADDRSS_I_S_U_TR'
GO
CREATE TRIGGER [dbo].[PIMS_ADDRSS_I_S_U_TR] ON PIMS_ADDRESS INSTEAD OF UPDATE AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM deleted)
    RETURN;

  -- validate concurrency control
  if exists (select 1 from inserted, deleted where inserted.CONCURRENCY_CONTROL_NUMBER != deleted.CONCURRENCY_CONTROL_NUMBER+1 AND inserted.ADDRESS_ID = deleted.ADDRESS_ID)
    raiserror('CONCURRENCY FAILURE.',16,1)


  -- update statement
  update PIMS_ADDRESS
    set "ADDRESS_ID" = inserted."ADDRESS_ID",
      "ADDRESS_USAGE_TYPE_CODE" = inserted."ADDRESS_USAGE_TYPE_CODE",
      "REGION_CODE" = inserted."REGION_CODE",
      "DISTRICT_CODE" = inserted."DISTRICT_CODE",
      "PROVINCE_STATE_ID" = inserted."PROVINCE_STATE_ID",
      "COUNTRY_ID" = inserted."COUNTRY_ID",
      "STREET_ADDRESS_1" = inserted."STREET_ADDRESS_1",
      "STREET_ADDRESS_2" = inserted."STREET_ADDRESS_2",
      "STREET_ADDRESS_3" = inserted."STREET_ADDRESS_3",
      "MUNICIPALITY_NAME" = inserted."MUNICIPALITY_NAME",
      "POSTAL_CODE" = inserted."POSTAL_CODE",
      "LATITUDE" = inserted."LATITUDE",
      "LONGITUDE" = inserted."LONGITUDE",
      "COMMENT" = inserted."COMMENT",
      "CONCURRENCY_CONTROL_NUMBER" = inserted."CONCURRENCY_CONTROL_NUMBER",
      "APP_LAST_UPDATE_TIMESTAMP" = inserted."APP_LAST_UPDATE_TIMESTAMP",
      "APP_LAST_UPDATE_USERID" = inserted."APP_LAST_UPDATE_USERID",
      "APP_LAST_UPDATE_USER_GUID" = inserted."APP_LAST_UPDATE_USER_GUID",
      "APP_LAST_UPDATE_USER_DIRECTORY" = inserted."APP_LAST_UPDATE_USER_DIRECTORY"
    , DB_LAST_UPDATE_TIMESTAMP = getutcdate()
    , DB_LAST_UPDATE_USERID = user_name()
    from PIMS_ADDRESS
    inner join inserted
    on (PIMS_ADDRESS.ADDRESS_ID = inserted.ADDRESS_ID);

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC pims_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger dbo.PIMS_TENANT_A_S_IUD_TR
PRINT N'Create trigger dbo.PIMS_TENANT_A_S_IUD_TR'
GO
CREATE TRIGGER [dbo].[PIMS_TENANT_A_S_IUD_TR] ON PIMS_LEASE_TENANT FOR INSERT, UPDATE, DELETE AS
SET NOCOUNT ON
BEGIN TRY
DECLARE @curr_date datetime;
SET @curr_date = getutcdate();
  IF NOT EXISTS(SELECT * FROM inserted) AND NOT EXISTS(SELECT * FROM deleted)
    RETURN;

  -- historical
  IF EXISTS(SELECT * FROM deleted)
    update PIMS_LEASE_TENANT_HIST set END_DATE_HIST = @curr_date where LEASE_TENANT_ID in (select LEASE_TENANT_ID from deleted) and END_DATE_HIST is null;

  IF EXISTS(SELECT * FROM inserted)
    insert into PIMS_LEASE_TENANT_HIST ([LEASE_TENANT_ID], [LEASE_ID], [PERSON_ID], [ORGANIZATION_ID], [LESSOR_TYPE_CODE], [NOTE], [CONCURRENCY_CONTROL_NUMBER], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [DB_CREATE_TIMESTAMP], [DB_CREATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], _LEASE_TENANT_HIST_ID, END_DATE_HIST, EFFECTIVE_DATE_HIST)
      select [LEASE_TENANT_ID], [LEASE_ID], [PERSON_ID], [ORGANIZATION_ID], [LESSOR_TYPE_CODE], [NOTE], [CONCURRENCY_CONTROL_NUMBER], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [DB_CREATE_TIMESTAMP], [DB_CREATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], (next value for [dbo].[PIMS_LEASE_TENANT_H_ID_SEQ]) as [_LEASE_TENANT_HIST_ID], null as [END_DATE_HIST], @curr_date as [EFFECTIVE_DATE_HIST] from inserted;

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC pims_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger dbo.PIMS_LSPYMT_A_S_IUD_TR
PRINT N'Create trigger dbo.PIMS_LSPYMT_A_S_IUD_TR'
GO
CREATE TRIGGER [dbo].[PIMS_LSPYMT_A_S_IUD_TR] ON PIMS_LEASE_PAYMENT FOR INSERT, UPDATE, DELETE AS
SET NOCOUNT ON
BEGIN TRY
DECLARE @curr_date datetime;
SET @curr_date = getutcdate();
  IF NOT EXISTS(SELECT * FROM inserted) AND NOT EXISTS(SELECT * FROM deleted)
    RETURN;

  -- historical
  IF EXISTS(SELECT * FROM deleted)
    update PIMS_LEASE_PAYMENT_HIST set END_DATE_HIST = @curr_date where LEASE_PAYMENT_ID in (select LEASE_PAYMENT_ID from deleted) and END_DATE_HIST is null;

  IF EXISTS(SELECT * FROM inserted)
    insert into PIMS_LEASE_PAYMENT_HIST ([LEASE_PAYMENT_ID], [LEASE_TERM_ID], [LEASE_PAYMENT_PERIOD_ID], [LEASE_PAYMENT_METHOD_TYPE_CODE], [PAYMENT_RECEIVED_DATE], [PAYMENT_AMOUNT_PRE_TAX], [PAYMENT_AMOUNT_PST], [PAYMENT_AMOUNT_GST], [PAYMENT_AMOUNT_TOTAL], [NOTE], [CONCURRENCY_CONTROL_NUMBER], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [DB_CREATE_TIMESTAMP], [DB_CREATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], _LEASE_PAYMENT_HIST_ID, END_DATE_HIST, EFFECTIVE_DATE_HIST)
      select [LEASE_PAYMENT_ID], [LEASE_TERM_ID], [LEASE_PAYMENT_PERIOD_ID], [LEASE_PAYMENT_METHOD_TYPE_CODE], [PAYMENT_RECEIVED_DATE], [PAYMENT_AMOUNT_PRE_TAX], [PAYMENT_AMOUNT_PST], [PAYMENT_AMOUNT_GST], [PAYMENT_AMOUNT_TOTAL], [NOTE], [CONCURRENCY_CONTROL_NUMBER], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [DB_CREATE_TIMESTAMP], [DB_CREATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], (next value for [dbo].[PIMS_LEASE_PAYMENT_H_ID_SEQ]) as [_LEASE_PAYMENT_HIST_ID], null as [END_DATE_HIST], @curr_date as [EFFECTIVE_DATE_HIST] from inserted;

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC pims_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger dbo.PIMS_PROJCT_A_S_IUD_TR
PRINT N'Create trigger dbo.PIMS_PROJCT_A_S_IUD_TR'
GO
/* ---------------------------------------------------------------------- */
/* Add triggers                                                           */
/* ---------------------------------------------------------------------- */

CREATE TRIGGER [dbo].[PIMS_PROJCT_A_S_IUD_TR] ON PIMS_PROJECT FOR INSERT, UPDATE, DELETE AS
SET NOCOUNT ON
BEGIN TRY
DECLARE @curr_date datetime;
SET @curr_date = getutcdate();
  IF NOT EXISTS(SELECT * FROM inserted) AND NOT EXISTS(SELECT * FROM deleted)
    RETURN;

  -- historical
  IF EXISTS(SELECT * FROM deleted)
    update PIMS_PROJECT_HIST set END_DATE_HIST = @curr_date where PROJECT_ID in (select PROJECT_ID from deleted) and END_DATE_HIST is null;

  IF EXISTS(SELECT * FROM inserted)
    insert into PIMS_PROJECT_HIST ([PROJECT_ID], [PROJECT_TYPE_CODE], [PROJECT_STATUS_TYPE_CODE], [PROJECT_RISK_TYPE_CODE], [PROJECT_TIER_TYPE_CODE], [CONCURRENCY_CONTROL_NUMBER], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [DB_CREATE_TIMESTAMP], [DB_CREATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], _PROJECT_HIST_ID, END_DATE_HIST, EFFECTIVE_DATE_HIST)
      select [PROJECT_ID], [PROJECT_TYPE_CODE], [PROJECT_STATUS_TYPE_CODE], [PROJECT_RISK_TYPE_CODE], [PROJECT_TIER_TYPE_CODE], [CONCURRENCY_CONTROL_NUMBER], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [DB_CREATE_TIMESTAMP], [DB_CREATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], (next value for [dbo].[PIMS_PROJECT_H_ID_SEQ]) as [_PROJECT_HIST_ID], null as [END_DATE_HIST], @curr_date as [EFFECTIVE_DATE_HIST] from inserted;

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC pims_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger dbo.PIMS_LINITT_I_S_I_TR
PRINT N'Create trigger dbo.PIMS_LINITT_I_S_I_TR'
GO
CREATE TRIGGER [dbo].[PIMS_LINITT_I_S_I_TR] ON PIMS_LEASE_INITIATOR_TYPE INSTEAD OF INSERT AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM inserted)
    RETURN;


  insert into PIMS_LEASE_INITIATOR_TYPE ("LEASE_INITIATOR_TYPE_CODE",
      "DESCRIPTION",
      "IS_DISABLED",
      "DISPLAY_ORDER",
      "CONCURRENCY_CONTROL_NUMBER")
    select "LEASE_INITIATOR_TYPE_CODE",
      "DESCRIPTION",
      "IS_DISABLED",
      "DISPLAY_ORDER",
      "CONCURRENCY_CONTROL_NUMBER"
    from inserted;

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC pims_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger dbo.PIMS_LPFCST_A_S_IUD_TR
PRINT N'Create trigger dbo.PIMS_LPFCST_A_S_IUD_TR'
GO
CREATE TRIGGER [dbo].[PIMS_LPFCST_A_S_IUD_TR] ON PIMS_LEASE_PAYMENT_FORECAST FOR INSERT, UPDATE, DELETE AS
SET NOCOUNT ON
BEGIN TRY
DECLARE @curr_date datetime;
SET @curr_date = getutcdate();
  IF NOT EXISTS(SELECT * FROM inserted) AND NOT EXISTS(SELECT * FROM deleted)
    RETURN;

  -- historical
  IF EXISTS(SELECT * FROM deleted)
    update PIMS_LEASE_PAYMENT_FORECAST_HIST set END_DATE_HIST = @curr_date where LEASE_PAYMENT_FORECAST_ID in (select LEASE_PAYMENT_FORECAST_ID from deleted) and END_DATE_HIST is null;

  IF EXISTS(SELECT * FROM inserted)
    insert into PIMS_LEASE_PAYMENT_FORECAST_HIST ([LEASE_PAYMENT_FORECAST_ID], [LEASE_TERM_ID], [LEASE_PAYMENT_PERIOD_ID], [LEASE_PAYMENT_STATUS_TYPE_CODE], [PAYMENT_DUE_DATE], [FORECAST_PAYMENT_PRE_TAX], [FORECAST_PAYMENT_PST], [FORECAST_PAYMENT_GST], [FORECAST_PAYMENT_TOTAL], [CONCURRENCY_CONTROL_NUMBER], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [DB_CREATE_TIMESTAMP], [DB_CREATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], _LEASE_PAYMENT_FORECAST_HIST_ID, END_DATE_HIST, EFFECTIVE_DATE_HIST)
      select [LEASE_PAYMENT_FORECAST_ID], [LEASE_TERM_ID], [LEASE_PAYMENT_PERIOD_ID], [LEASE_PAYMENT_STATUS_TYPE_CODE], [PAYMENT_DUE_DATE], [FORECAST_PAYMENT_PRE_TAX], [FORECAST_PAYMENT_PST], [FORECAST_PAYMENT_GST], [FORECAST_PAYMENT_TOTAL], [CONCURRENCY_CONTROL_NUMBER], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [DB_CREATE_TIMESTAMP], [DB_CREATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], (next value for [dbo].[PIMS_LEASE_PAYMENT_FORECAST_H_ID_SEQ]) as [_LEASE_PAYMENT_FORECAST_HIST_ID], null as [END_DATE_HIST], @curr_date as [EFFECTIVE_DATE_HIST] from inserted;

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC pims_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger dbo.PIMS_LTRMST_I_S_I_TR
PRINT N'Create trigger dbo.PIMS_LTRMST_I_S_I_TR'
GO
CREATE TRIGGER [dbo].[PIMS_LTRMST_I_S_I_TR] ON PIMS_LEASE_TERM_STATUS_TYPE INSTEAD OF INSERT AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM inserted)
    RETURN;


  insert into PIMS_LEASE_TERM_STATUS_TYPE ("LEASE_TERM_STATUS_TYPE_CODE",
      "DESCRIPTION",
      "IS_DISABLED",
      "DISPLAY_ORDER",
      "CONCURRENCY_CONTROL_NUMBER")
    select "LEASE_TERM_STATUS_TYPE_CODE",
      "DESCRIPTION",
      "IS_DISABLED",
      "DISPLAY_ORDER",
      "CONCURRENCY_CONTROL_NUMBER"
    from inserted;

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC pims_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger dbo.PIMS_ORG_I_S_U_TR
PRINT N'Create trigger dbo.PIMS_ORG_I_S_U_TR'
GO
CREATE TRIGGER [dbo].[PIMS_ORG_I_S_U_TR] ON PIMS_ORGANIZATION INSTEAD OF UPDATE AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM deleted)
    RETURN;

  -- validate concurrency control
  if exists (select 1 from inserted, deleted where inserted.CONCURRENCY_CONTROL_NUMBER != deleted.CONCURRENCY_CONTROL_NUMBER+1 AND inserted.ORGANIZATION_ID = deleted.ORGANIZATION_ID)
    raiserror('CONCURRENCY FAILURE.',16,1)


  -- update statement
  update PIMS_ORGANIZATION
    set "ORGANIZATION_ID" = inserted."ORGANIZATION_ID",
      "PRNT_ORGANIZATION_ID" = inserted."PRNT_ORGANIZATION_ID",
      "ADDRESS_ID" = inserted."ADDRESS_ID",
      "REGION_CODE" = inserted."REGION_CODE",
      "DISTRICT_CODE" = inserted."DISTRICT_CODE",
      "ORGANIZATION_TYPE_CODE" = inserted."ORGANIZATION_TYPE_CODE",
      "ORG_IDENTIFIER_TYPE_CODE" = inserted."ORG_IDENTIFIER_TYPE_CODE",
      "ORGANIZATION_IDENTIFIER" = inserted."ORGANIZATION_IDENTIFIER",
      "ORGANIZATION_NAME" = inserted."ORGANIZATION_NAME",
      "ORGANIZATION_ALIAS" = inserted."ORGANIZATION_ALIAS",
      "WEBSITE" = inserted."WEBSITE",
      "IS_DISABLED" = inserted."IS_DISABLED",
      "CONCURRENCY_CONTROL_NUMBER" = inserted."CONCURRENCY_CONTROL_NUMBER",
      "APP_LAST_UPDATE_TIMESTAMP" = inserted."APP_LAST_UPDATE_TIMESTAMP",
      "APP_LAST_UPDATE_USERID" = inserted."APP_LAST_UPDATE_USERID",
      "APP_LAST_UPDATE_USER_GUID" = inserted."APP_LAST_UPDATE_USER_GUID",
      "APP_LAST_UPDATE_USER_DIRECTORY" = inserted."APP_LAST_UPDATE_USER_DIRECTORY"
    , DB_LAST_UPDATE_TIMESTAMP = getutcdate()
    , DB_LAST_UPDATE_USERID = user_name()
    from PIMS_ORGANIZATION
    inner join inserted
    on (PIMS_ORGANIZATION.ORGANIZATION_ID = inserted.ORGANIZATION_ID);

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC pims_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger dbo.PIMS_LRESPT_I_S_U_TR
PRINT N'Create trigger dbo.PIMS_LRESPT_I_S_U_TR'
GO
CREATE TRIGGER [dbo].[PIMS_LRESPT_I_S_U_TR] ON PIMS_LEASE_RESPONSIBILITY_TYPE INSTEAD OF UPDATE AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM deleted)
    RETURN;

  -- validate concurrency control
  if exists (select 1 from inserted, deleted where inserted.CONCURRENCY_CONTROL_NUMBER != deleted.CONCURRENCY_CONTROL_NUMBER+1 AND inserted.LEASE_RESPONSIBILITY_TYPE_CODE = deleted.LEASE_RESPONSIBILITY_TYPE_CODE)
    raiserror('CONCURRENCY FAILURE.',16,1)


  -- update statement
  update PIMS_LEASE_RESPONSIBILITY_TYPE
    set "LEASE_RESPONSIBILITY_TYPE_CODE" = inserted."LEASE_RESPONSIBILITY_TYPE_CODE",
      "DESCRIPTION" = inserted."DESCRIPTION",
      "IS_DISABLED" = inserted."IS_DISABLED",
      "DISPLAY_ORDER" = inserted."DISPLAY_ORDER",
      "CONCURRENCY_CONTROL_NUMBER" = inserted."CONCURRENCY_CONTROL_NUMBER"
    , DB_LAST_UPDATE_TIMESTAMP = getutcdate()
    , DB_LAST_UPDATE_USERID = user_name()
    from PIMS_LEASE_RESPONSIBILITY_TYPE
    inner join inserted
    on (PIMS_LEASE_RESPONSIBILITY_TYPE.LEASE_RESPONSIBILITY_TYPE_CODE = inserted.LEASE_RESPONSIBILITY_TYPE_CODE);

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC pims_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger dbo.PIMS_PIMPRV_I_S_U_TR
PRINT N'Create trigger dbo.PIMS_PIMPRV_I_S_U_TR'
GO
CREATE TRIGGER [dbo].[PIMS_PIMPRV_I_S_U_TR] ON PIMS_PROPERTY_IMPROVEMENT INSTEAD OF UPDATE AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM deleted)
    RETURN;

  -- validate concurrency control
  if exists (select 1 from inserted, deleted where inserted.CONCURRENCY_CONTROL_NUMBER != deleted.CONCURRENCY_CONTROL_NUMBER+1 AND inserted.PROPERTY_IMPROVEMENT_ID = deleted.PROPERTY_IMPROVEMENT_ID)
    raiserror('CONCURRENCY FAILURE.',16,1)


  -- update statement
  update PIMS_PROPERTY_IMPROVEMENT
    set "PROPERTY_IMPROVEMENT_ID" = inserted."PROPERTY_IMPROVEMENT_ID",
      "PROPERTY_LEASE_ID" = inserted."PROPERTY_LEASE_ID",
      "PROPERTY_IMPROVEMENT_TYPE_CODE" = inserted."PROPERTY_IMPROVEMENT_TYPE_CODE",
      "IMPROVEMENT_DESCRIPTION" = inserted."IMPROVEMENT_DESCRIPTION",
      "STRUCTURE_SIZE" = inserted."STRUCTURE_SIZE",
      "UNIT" = inserted."UNIT",
      "CONCURRENCY_CONTROL_NUMBER" = inserted."CONCURRENCY_CONTROL_NUMBER",
      "APP_LAST_UPDATE_TIMESTAMP" = inserted."APP_LAST_UPDATE_TIMESTAMP",
      "APP_LAST_UPDATE_USERID" = inserted."APP_LAST_UPDATE_USERID",
      "APP_LAST_UPDATE_USER_GUID" = inserted."APP_LAST_UPDATE_USER_GUID",
      "APP_LAST_UPDATE_USER_DIRECTORY" = inserted."APP_LAST_UPDATE_USER_DIRECTORY"
    , DB_LAST_UPDATE_TIMESTAMP = getutcdate()
    , DB_LAST_UPDATE_USERID = user_name()
    from PIMS_PROPERTY_IMPROVEMENT
    inner join inserted
    on (PIMS_PROPERTY_IMPROVEMENT.PROPERTY_IMPROVEMENT_ID = inserted.PROPERTY_IMPROVEMENT_ID);

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC pims_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger dbo.PIMS_LTRMST_I_S_U_TR
PRINT N'Create trigger dbo.PIMS_LTRMST_I_S_U_TR'
GO
CREATE TRIGGER [dbo].[PIMS_LTRMST_I_S_U_TR] ON PIMS_LEASE_TERM_STATUS_TYPE INSTEAD OF UPDATE AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM deleted)
    RETURN;

  -- validate concurrency control
  if exists (select 1 from inserted, deleted where inserted.CONCURRENCY_CONTROL_NUMBER != deleted.CONCURRENCY_CONTROL_NUMBER+1 AND inserted.LEASE_TERM_STATUS_TYPE_CODE = deleted.LEASE_TERM_STATUS_TYPE_CODE)
    raiserror('CONCURRENCY FAILURE.',16,1)


  -- update statement
  update PIMS_LEASE_TERM_STATUS_TYPE
    set "LEASE_TERM_STATUS_TYPE_CODE" = inserted."LEASE_TERM_STATUS_TYPE_CODE",
      "DESCRIPTION" = inserted."DESCRIPTION",
      "IS_DISABLED" = inserted."IS_DISABLED",
      "DISPLAY_ORDER" = inserted."DISPLAY_ORDER",
      "CONCURRENCY_CONTROL_NUMBER" = inserted."CONCURRENCY_CONTROL_NUMBER"
    , DB_LAST_UPDATE_TIMESTAMP = getutcdate()
    , DB_LAST_UPDATE_USERID = user_name()
    from PIMS_LEASE_TERM_STATUS_TYPE
    inner join inserted
    on (PIMS_LEASE_TERM_STATUS_TYPE.LEASE_TERM_STATUS_TYPE_CODE = inserted.LEASE_TERM_STATUS_TYPE_CODE);

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC pims_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger dbo.PIMS_PERSON_I_S_U_TR
PRINT N'Create trigger dbo.PIMS_PERSON_I_S_U_TR'
GO
CREATE TRIGGER [dbo].[PIMS_PERSON_I_S_U_TR] ON PIMS_PERSON INSTEAD OF UPDATE AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM deleted)
    RETURN;

  -- validate concurrency control
  if exists (select 1 from inserted, deleted where inserted.CONCURRENCY_CONTROL_NUMBER != deleted.CONCURRENCY_CONTROL_NUMBER+1 AND inserted.PERSON_ID = deleted.PERSON_ID)
    raiserror('CONCURRENCY FAILURE.',16,1)


  -- update statement
  update PIMS_PERSON
    set "PERSON_ID" = inserted."PERSON_ID",
      "ADDRESS_ID" = inserted."ADDRESS_ID",
      "SURNAME" = inserted."SURNAME",
      "FIRST_NAME" = inserted."FIRST_NAME",
      "MIDDLE_NAMES" = inserted."MIDDLE_NAMES",
      "NAME_SUFFIX" = inserted."NAME_SUFFIX",
      "PREFERRED_NAME" = inserted."PREFERRED_NAME",
      "BIRTH_DATE" = inserted."BIRTH_DATE",
      "IS_DISABLED" = inserted."IS_DISABLED",
      "CONCURRENCY_CONTROL_NUMBER" = inserted."CONCURRENCY_CONTROL_NUMBER",
      "APP_LAST_UPDATE_TIMESTAMP" = inserted."APP_LAST_UPDATE_TIMESTAMP",
      "APP_LAST_UPDATE_USERID" = inserted."APP_LAST_UPDATE_USERID",
      "APP_LAST_UPDATE_USER_GUID" = inserted."APP_LAST_UPDATE_USER_GUID",
      "APP_LAST_UPDATE_USER_DIRECTORY" = inserted."APP_LAST_UPDATE_USER_DIRECTORY"
    , DB_LAST_UPDATE_TIMESTAMP = getutcdate()
    , DB_LAST_UPDATE_USERID = user_name()
    from PIMS_PERSON
    inner join inserted
    on (PIMS_PERSON.PERSON_ID = inserted.PERSON_ID);

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC pims_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger dbo.PIMS_ORG_I_S_I_TR
PRINT N'Create trigger dbo.PIMS_ORG_I_S_I_TR'
GO
CREATE TRIGGER [dbo].[PIMS_ORG_I_S_I_TR] ON PIMS_ORGANIZATION INSTEAD OF INSERT AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM inserted)
    RETURN;


  insert into PIMS_ORGANIZATION ("ORGANIZATION_ID",
      "PRNT_ORGANIZATION_ID",
      "ADDRESS_ID",
      "REGION_CODE",
      "DISTRICT_CODE",
      "ORGANIZATION_TYPE_CODE",
      "ORG_IDENTIFIER_TYPE_CODE",
      "ORGANIZATION_IDENTIFIER",
      "ORGANIZATION_NAME",
      "ORGANIZATION_ALIAS",
      "WEBSITE",
      "IS_DISABLED",
      "CONCURRENCY_CONTROL_NUMBER",
      "APP_CREATE_TIMESTAMP",
      "APP_CREATE_USERID",
      "APP_CREATE_USER_GUID",
      "APP_CREATE_USER_DIRECTORY",
      "APP_LAST_UPDATE_TIMESTAMP",
      "APP_LAST_UPDATE_USERID",
      "APP_LAST_UPDATE_USER_GUID",
      "APP_LAST_UPDATE_USER_DIRECTORY")
    select "ORGANIZATION_ID",
      "PRNT_ORGANIZATION_ID",
      "ADDRESS_ID",
      "REGION_CODE",
      "DISTRICT_CODE",
      "ORGANIZATION_TYPE_CODE",
      "ORG_IDENTIFIER_TYPE_CODE",
      "ORGANIZATION_IDENTIFIER",
      "ORGANIZATION_NAME",
      "ORGANIZATION_ALIAS",
      "WEBSITE",
      "IS_DISABLED",
      "CONCURRENCY_CONTROL_NUMBER",
      "APP_CREATE_TIMESTAMP",
      "APP_CREATE_USERID",
      "APP_CREATE_USER_GUID",
      "APP_CREATE_USER_DIRECTORY",
      "APP_LAST_UPDATE_TIMESTAMP",
      "APP_LAST_UPDATE_USERID",
      "APP_LAST_UPDATE_USER_GUID",
      "APP_LAST_UPDATE_USER_DIRECTORY"
    from inserted;

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC pims_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger dbo.PIMS_LPYPER_A_S_IUD_TR
PRINT N'Create trigger dbo.PIMS_LPYPER_A_S_IUD_TR'
GO
CREATE TRIGGER [dbo].[PIMS_LPYPER_A_S_IUD_TR] ON PIMS_LEASE_PAYMENT_PERIOD FOR INSERT, UPDATE, DELETE AS
SET NOCOUNT ON
BEGIN TRY
DECLARE @curr_date datetime;
SET @curr_date = getutcdate();
  IF NOT EXISTS(SELECT * FROM inserted) AND NOT EXISTS(SELECT * FROM deleted)
    RETURN;

  -- historical
  IF EXISTS(SELECT * FROM deleted)
    update PIMS_LEASE_PAYMENT_PERIOD_HIST set END_DATE_HIST = @curr_date where LEASE_PAYMENT_PERIOD_ID in (select LEASE_PAYMENT_PERIOD_ID from deleted) and END_DATE_HIST is null;

  IF EXISTS(SELECT * FROM inserted)
    insert into PIMS_LEASE_PAYMENT_PERIOD_HIST ([LEASE_PAYMENT_PERIOD_ID], [PERIOD_START_DATE], [IS_PERIOD_CLOSED], [CONCURRENCY_CONTROL_NUMBER], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [DB_CREATE_TIMESTAMP], [DB_CREATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], _LEASE_PAYMENT_PERIOD_HIST_ID, END_DATE_HIST, EFFECTIVE_DATE_HIST)
      select [LEASE_PAYMENT_PERIOD_ID], [PERIOD_START_DATE], [IS_PERIOD_CLOSED], [CONCURRENCY_CONTROL_NUMBER], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [DB_CREATE_TIMESTAMP], [DB_CREATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], (next value for [dbo].[PIMS_LEASE_PAYMENT_PERIOD_H_ID_SEQ]) as [_LEASE_PAYMENT_PERIOD_HIST_ID], null as [END_DATE_HIST], @curr_date as [EFFECTIVE_DATE_HIST] from inserted;

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC pims_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger dbo.PIMS_PERSON_A_S_IUD_TR
PRINT N'Create trigger dbo.PIMS_PERSON_A_S_IUD_TR'
GO
CREATE TRIGGER [dbo].[PIMS_PERSON_A_S_IUD_TR] ON PIMS_PERSON FOR INSERT, UPDATE, DELETE AS
SET NOCOUNT ON
BEGIN TRY
DECLARE @curr_date datetime;
SET @curr_date = getutcdate();
  IF NOT EXISTS(SELECT * FROM inserted) AND NOT EXISTS(SELECT * FROM deleted)
    RETURN;

  -- historical
  IF EXISTS(SELECT * FROM deleted)
    update PIMS_PERSON_HIST set END_DATE_HIST = @curr_date where PERSON_ID in (select PERSON_ID from deleted) and END_DATE_HIST is null;

  IF EXISTS(SELECT * FROM inserted)
    insert into PIMS_PERSON_HIST ([PERSON_ID], [ADDRESS_ID], [SURNAME], [FIRST_NAME], [MIDDLE_NAMES], [NAME_SUFFIX], [PREFERRED_NAME], [BIRTH_DATE], [IS_DISABLED], [CONCURRENCY_CONTROL_NUMBER], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [DB_CREATE_TIMESTAMP], [DB_CREATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], _PERSON_HIST_ID, END_DATE_HIST, EFFECTIVE_DATE_HIST)
      select [PERSON_ID], [ADDRESS_ID], [SURNAME], [FIRST_NAME], [MIDDLE_NAMES], [NAME_SUFFIX], [PREFERRED_NAME], [BIRTH_DATE], [IS_DISABLED], [CONCURRENCY_CONTROL_NUMBER], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [DB_CREATE_TIMESTAMP], [DB_CREATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], (next value for [dbo].[PIMS_PERSON_H_ID_SEQ]) as [_PERSON_HIST_ID], null as [END_DATE_HIST], @curr_date as [EFFECTIVE_DATE_HIST] from inserted;

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC pims_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger dbo.PIMS_LSPMMT_I_S_I_TR
PRINT N'Create trigger dbo.PIMS_LSPMMT_I_S_I_TR'
GO
CREATE TRIGGER [dbo].[PIMS_LSPMMT_I_S_I_TR] ON PIMS_LEASE_PAYMENT_METHOD_TYPE INSTEAD OF INSERT AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM inserted)
    RETURN;


  insert into PIMS_LEASE_PAYMENT_METHOD_TYPE ("LEASE_PAYMENT_METHOD_TYPE_CODE",
      "DESCRIPTION",
      "IS_DISABLED",
      "DISPLAY_ORDER",
      "CONCURRENCY_CONTROL_NUMBER")
    select "LEASE_PAYMENT_METHOD_TYPE_CODE",
      "DESCRIPTION",
      "IS_DISABLED",
      "DISPLAY_ORDER",
      "CONCURRENCY_CONTROL_NUMBER"
    from inserted;

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC pims_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger dbo.PIMS_LPSTST_I_S_U_TR
PRINT N'Create trigger dbo.PIMS_LPSTST_I_S_U_TR'
GO
CREATE TRIGGER [dbo].[PIMS_LPSTST_I_S_U_TR] ON PIMS_LEASE_PAYMENT_STATUS_TYPE INSTEAD OF UPDATE AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM deleted)
    RETURN;

  -- validate concurrency control
  if exists (select 1 from inserted, deleted where inserted.CONCURRENCY_CONTROL_NUMBER != deleted.CONCURRENCY_CONTROL_NUMBER+1 AND inserted.LEASE_PAYMENT_STATUS_TYPE_CODE = deleted.LEASE_PAYMENT_STATUS_TYPE_CODE)
    raiserror('CONCURRENCY FAILURE.',16,1)


  -- update statement
  update PIMS_LEASE_PAYMENT_STATUS_TYPE
    set "LEASE_PAYMENT_STATUS_TYPE_CODE" = inserted."LEASE_PAYMENT_STATUS_TYPE_CODE",
      "DESCRIPTION" = inserted."DESCRIPTION",
      "IS_DISABLED" = inserted."IS_DISABLED",
      "DISPLAY_ORDER" = inserted."DISPLAY_ORDER",
      "CONCURRENCY_CONTROL_NUMBER" = inserted."CONCURRENCY_CONTROL_NUMBER"
    , DB_LAST_UPDATE_TIMESTAMP = getutcdate()
    , DB_LAST_UPDATE_USERID = user_name()
    from PIMS_LEASE_PAYMENT_STATUS_TYPE
    inner join inserted
    on (PIMS_LEASE_PAYMENT_STATUS_TYPE.LEASE_PAYMENT_STATUS_TYPE_CODE = inserted.LEASE_PAYMENT_STATUS_TYPE_CODE);

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC pims_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger dbo.PIMS_LPFCST_I_S_U_TR
PRINT N'Create trigger dbo.PIMS_LPFCST_I_S_U_TR'
GO
CREATE TRIGGER [dbo].[PIMS_LPFCST_I_S_U_TR] ON PIMS_LEASE_PAYMENT_FORECAST INSTEAD OF UPDATE AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM deleted)
    RETURN;

  -- validate concurrency control
  if exists (select 1 from inserted, deleted where inserted.CONCURRENCY_CONTROL_NUMBER != deleted.CONCURRENCY_CONTROL_NUMBER+1 AND inserted.LEASE_PAYMENT_FORECAST_ID = deleted.LEASE_PAYMENT_FORECAST_ID)
    raiserror('CONCURRENCY FAILURE.',16,1)


  -- update statement
  update PIMS_LEASE_PAYMENT_FORECAST
    set "LEASE_PAYMENT_FORECAST_ID" = inserted."LEASE_PAYMENT_FORECAST_ID",
      "LEASE_TERM_ID" = inserted."LEASE_TERM_ID",
      "LEASE_PAYMENT_PERIOD_ID" = inserted."LEASE_PAYMENT_PERIOD_ID",
      "LEASE_PAYMENT_STATUS_TYPE_CODE" = inserted."LEASE_PAYMENT_STATUS_TYPE_CODE",
      "PAYMENT_DUE_DATE" = inserted."PAYMENT_DUE_DATE",
      "FORECAST_PAYMENT_PRE_TAX" = inserted."FORECAST_PAYMENT_PRE_TAX",
      "FORECAST_PAYMENT_PST" = inserted."FORECAST_PAYMENT_PST",
      "FORECAST_PAYMENT_GST" = inserted."FORECAST_PAYMENT_GST",
      "FORECAST_PAYMENT_TOTAL" = inserted."FORECAST_PAYMENT_TOTAL",
      "CONCURRENCY_CONTROL_NUMBER" = inserted."CONCURRENCY_CONTROL_NUMBER",
      "APP_LAST_UPDATE_TIMESTAMP" = inserted."APP_LAST_UPDATE_TIMESTAMP",
      "APP_LAST_UPDATE_USERID" = inserted."APP_LAST_UPDATE_USERID",
      "APP_LAST_UPDATE_USER_GUID" = inserted."APP_LAST_UPDATE_USER_GUID",
      "APP_LAST_UPDATE_USER_DIRECTORY" = inserted."APP_LAST_UPDATE_USER_DIRECTORY"
    , DB_LAST_UPDATE_TIMESTAMP = getutcdate()
    , DB_LAST_UPDATE_USERID = user_name()
    from PIMS_LEASE_PAYMENT_FORECAST
    inner join inserted
    on (PIMS_LEASE_PAYMENT_FORECAST.LEASE_PAYMENT_FORECAST_ID = inserted.LEASE_PAYMENT_FORECAST_ID);

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC pims_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger dbo.PIMS_TENANT_I_S_I_TR
PRINT N'Create trigger dbo.PIMS_TENANT_I_S_I_TR'
GO
CREATE TRIGGER [dbo].[PIMS_TENANT_I_S_I_TR] ON PIMS_LEASE_TENANT INSTEAD OF INSERT AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM inserted)
    RETURN;


  insert into PIMS_LEASE_TENANT ("LEASE_TENANT_ID",
      "LEASE_ID",
      "PERSON_ID",
      "ORGANIZATION_ID",
      "LESSOR_TYPE_CODE",
      "NOTE",
      "CONCURRENCY_CONTROL_NUMBER",
      "APP_CREATE_TIMESTAMP",
      "APP_CREATE_USERID",
      "APP_CREATE_USER_GUID",
      "APP_CREATE_USER_DIRECTORY",
      "APP_LAST_UPDATE_TIMESTAMP",
      "APP_LAST_UPDATE_USERID",
      "APP_LAST_UPDATE_USER_GUID",
      "APP_LAST_UPDATE_USER_DIRECTORY")
    select "LEASE_TENANT_ID",
      "LEASE_ID",
      "PERSON_ID",
      "ORGANIZATION_ID",
      "LESSOR_TYPE_CODE",
      "NOTE",
      "CONCURRENCY_CONTROL_NUMBER",
      "APP_CREATE_TIMESTAMP",
      "APP_CREATE_USERID",
      "APP_CREATE_USER_GUID",
      "APP_CREATE_USER_DIRECTORY",
      "APP_LAST_UPDATE_TIMESTAMP",
      "APP_LAST_UPDATE_USERID",
      "APP_LAST_UPDATE_USER_GUID",
      "APP_LAST_UPDATE_USER_DIRECTORY"
    from inserted;

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC pims_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger dbo.PIMS_LSPMMT_I_S_U_TR
PRINT N'Create trigger dbo.PIMS_LSPMMT_I_S_U_TR'
GO
CREATE TRIGGER [dbo].[PIMS_LSPMMT_I_S_U_TR] ON PIMS_LEASE_PAYMENT_METHOD_TYPE INSTEAD OF UPDATE AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM deleted)
    RETURN;

  -- validate concurrency control
  if exists (select 1 from inserted, deleted where inserted.CONCURRENCY_CONTROL_NUMBER != deleted.CONCURRENCY_CONTROL_NUMBER+1 AND inserted.LEASE_PAYMENT_METHOD_TYPE_CODE = deleted.LEASE_PAYMENT_METHOD_TYPE_CODE)
    raiserror('CONCURRENCY FAILURE.',16,1)


  -- update statement
  update PIMS_LEASE_PAYMENT_METHOD_TYPE
    set "LEASE_PAYMENT_METHOD_TYPE_CODE" = inserted."LEASE_PAYMENT_METHOD_TYPE_CODE",
      "DESCRIPTION" = inserted."DESCRIPTION",
      "IS_DISABLED" = inserted."IS_DISABLED",
      "DISPLAY_ORDER" = inserted."DISPLAY_ORDER",
      "CONCURRENCY_CONTROL_NUMBER" = inserted."CONCURRENCY_CONTROL_NUMBER"
    , DB_LAST_UPDATE_TIMESTAMP = getutcdate()
    , DB_LAST_UPDATE_USERID = user_name()
    from PIMS_LEASE_PAYMENT_METHOD_TYPE
    inner join inserted
    on (PIMS_LEASE_PAYMENT_METHOD_TYPE.LEASE_PAYMENT_METHOD_TYPE_CODE = inserted.LEASE_PAYMENT_METHOD_TYPE_CODE);

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC pims_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger dbo.PIMS_LSPYMT_I_S_I_TR
PRINT N'Create trigger dbo.PIMS_LSPYMT_I_S_I_TR'
GO
CREATE TRIGGER [dbo].[PIMS_LSPYMT_I_S_I_TR] ON PIMS_LEASE_PAYMENT INSTEAD OF INSERT AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM inserted)
    RETURN;


  insert into PIMS_LEASE_PAYMENT ("LEASE_PAYMENT_ID",
      "LEASE_TERM_ID",
      "LEASE_PAYMENT_PERIOD_ID",
      "LEASE_PAYMENT_METHOD_TYPE_CODE",
      "PAYMENT_RECEIVED_DATE",
      "PAYMENT_AMOUNT_PRE_TAX",
      "PAYMENT_AMOUNT_PST",
      "PAYMENT_AMOUNT_GST",
      "PAYMENT_AMOUNT_TOTAL",
      "NOTE",
      "CONCURRENCY_CONTROL_NUMBER",
      "APP_CREATE_TIMESTAMP",
      "APP_CREATE_USERID",
      "APP_CREATE_USER_GUID",
      "APP_CREATE_USER_DIRECTORY",
      "APP_LAST_UPDATE_TIMESTAMP",
      "APP_LAST_UPDATE_USERID",
      "APP_LAST_UPDATE_USER_GUID",
      "APP_LAST_UPDATE_USER_DIRECTORY")
    select "LEASE_PAYMENT_ID",
      "LEASE_TERM_ID",
      "LEASE_PAYMENT_PERIOD_ID",
      "LEASE_PAYMENT_METHOD_TYPE_CODE",
      "PAYMENT_RECEIVED_DATE",
      "PAYMENT_AMOUNT_PRE_TAX",
      "PAYMENT_AMOUNT_PST",
      "PAYMENT_AMOUNT_GST",
      "PAYMENT_AMOUNT_TOTAL",
      "NOTE",
      "CONCURRENCY_CONTROL_NUMBER",
      "APP_CREATE_TIMESTAMP",
      "APP_CREATE_USERID",
      "APP_CREATE_USER_GUID",
      "APP_CREATE_USER_DIRECTORY",
      "APP_LAST_UPDATE_TIMESTAMP",
      "APP_LAST_UPDATE_USERID",
      "APP_LAST_UPDATE_USER_GUID",
      "APP_LAST_UPDATE_USER_DIRECTORY"
    from inserted;

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC pims_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger dbo.PIMS_PIMPRV_I_S_I_TR
PRINT N'Create trigger dbo.PIMS_PIMPRV_I_S_I_TR'
GO
CREATE TRIGGER [dbo].[PIMS_PIMPRV_I_S_I_TR] ON PIMS_PROPERTY_IMPROVEMENT INSTEAD OF INSERT AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM inserted)
    RETURN;


  insert into PIMS_PROPERTY_IMPROVEMENT ("PROPERTY_IMPROVEMENT_ID",
      "PROPERTY_LEASE_ID",
      "PROPERTY_IMPROVEMENT_TYPE_CODE",
      "IMPROVEMENT_DESCRIPTION",
      "STRUCTURE_SIZE",
      "UNIT",
      "CONCURRENCY_CONTROL_NUMBER",
      "APP_CREATE_TIMESTAMP",
      "APP_CREATE_USERID",
      "APP_CREATE_USER_GUID",
      "APP_CREATE_USER_DIRECTORY",
      "APP_LAST_UPDATE_TIMESTAMP",
      "APP_LAST_UPDATE_USERID",
      "APP_LAST_UPDATE_USER_GUID",
      "APP_LAST_UPDATE_USER_DIRECTORY")
    select "PROPERTY_IMPROVEMENT_ID",
      "PROPERTY_LEASE_ID",
      "PROPERTY_IMPROVEMENT_TYPE_CODE",
      "IMPROVEMENT_DESCRIPTION",
      "STRUCTURE_SIZE",
      "UNIT",
      "CONCURRENCY_CONTROL_NUMBER",
      "APP_CREATE_TIMESTAMP",
      "APP_CREATE_USERID",
      "APP_CREATE_USER_GUID",
      "APP_CREATE_USER_DIRECTORY",
      "APP_LAST_UPDATE_TIMESTAMP",
      "APP_LAST_UPDATE_USERID",
      "APP_LAST_UPDATE_USER_GUID",
      "APP_LAST_UPDATE_USER_DIRECTORY"
    from inserted;

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC pims_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger dbo.PIMS_LPFCST_I_S_I_TR
PRINT N'Create trigger dbo.PIMS_LPFCST_I_S_I_TR'
GO
CREATE TRIGGER [dbo].[PIMS_LPFCST_I_S_I_TR] ON PIMS_LEASE_PAYMENT_FORECAST INSTEAD OF INSERT AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM inserted)
    RETURN;


  insert into PIMS_LEASE_PAYMENT_FORECAST ("LEASE_PAYMENT_FORECAST_ID",
      "LEASE_TERM_ID",
      "LEASE_PAYMENT_PERIOD_ID",
      "LEASE_PAYMENT_STATUS_TYPE_CODE",
      "PAYMENT_DUE_DATE",
      "FORECAST_PAYMENT_PRE_TAX",
      "FORECAST_PAYMENT_PST",
      "FORECAST_PAYMENT_GST",
      "FORECAST_PAYMENT_TOTAL",
      "CONCURRENCY_CONTROL_NUMBER",
      "APP_CREATE_TIMESTAMP",
      "APP_CREATE_USERID",
      "APP_CREATE_USER_GUID",
      "APP_CREATE_USER_DIRECTORY",
      "APP_LAST_UPDATE_TIMESTAMP",
      "APP_LAST_UPDATE_USERID",
      "APP_LAST_UPDATE_USER_GUID",
      "APP_LAST_UPDATE_USER_DIRECTORY")
    select "LEASE_PAYMENT_FORECAST_ID",
      "LEASE_TERM_ID",
      "LEASE_PAYMENT_PERIOD_ID",
      "LEASE_PAYMENT_STATUS_TYPE_CODE",
      "PAYMENT_DUE_DATE",
      "FORECAST_PAYMENT_PRE_TAX",
      "FORECAST_PAYMENT_PST",
      "FORECAST_PAYMENT_GST",
      "FORECAST_PAYMENT_TOTAL",
      "CONCURRENCY_CONTROL_NUMBER",
      "APP_CREATE_TIMESTAMP",
      "APP_CREATE_USERID",
      "APP_CREATE_USER_GUID",
      "APP_CREATE_USER_DIRECTORY",
      "APP_LAST_UPDATE_TIMESTAMP",
      "APP_LAST_UPDATE_USERID",
      "APP_LAST_UPDATE_USER_GUID",
      "APP_LAST_UPDATE_USER_DIRECTORY"
    from inserted;

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC pims_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger dbo.PIMS_LRESPT_I_S_I_TR
PRINT N'Create trigger dbo.PIMS_LRESPT_I_S_I_TR'
GO
CREATE TRIGGER [dbo].[PIMS_LRESPT_I_S_I_TR] ON PIMS_LEASE_RESPONSIBILITY_TYPE INSTEAD OF INSERT AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM inserted)
    RETURN;


  insert into PIMS_LEASE_RESPONSIBILITY_TYPE ("LEASE_RESPONSIBILITY_TYPE_CODE",
      "DESCRIPTION",
      "IS_DISABLED",
      "DISPLAY_ORDER",
      "CONCURRENCY_CONTROL_NUMBER")
    select "LEASE_RESPONSIBILITY_TYPE_CODE",
      "DESCRIPTION",
      "IS_DISABLED",
      "DISPLAY_ORDER",
      "CONCURRENCY_CONTROL_NUMBER"
    from inserted;

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC pims_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger dbo.PIMS_ORG_A_S_IUD_TR
PRINT N'Create trigger dbo.PIMS_ORG_A_S_IUD_TR'
GO
CREATE TRIGGER [dbo].[PIMS_ORG_A_S_IUD_TR] ON PIMS_ORGANIZATION FOR INSERT, UPDATE, DELETE AS
SET NOCOUNT ON
BEGIN TRY
DECLARE @curr_date datetime;
SET @curr_date = getutcdate();
  IF NOT EXISTS(SELECT * FROM inserted) AND NOT EXISTS(SELECT * FROM deleted)
    RETURN;

  -- historical
  IF EXISTS(SELECT * FROM deleted)
    update PIMS_ORGANIZATION_HIST set END_DATE_HIST = @curr_date where ORGANIZATION_ID in (select ORGANIZATION_ID from deleted) and END_DATE_HIST is null;

  IF EXISTS(SELECT * FROM inserted)
    insert into PIMS_ORGANIZATION_HIST ([ORGANIZATION_ID], [PRNT_ORGANIZATION_ID], [ADDRESS_ID], [REGION_CODE], [DISTRICT_CODE], [ORGANIZATION_TYPE_CODE], [ORG_IDENTIFIER_TYPE_CODE], [ORGANIZATION_IDENTIFIER], [ORGANIZATION_NAME], [ORGANIZATION_ALIAS], [WEBSITE], [IS_DISABLED], [CONCURRENCY_CONTROL_NUMBER], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [DB_CREATE_TIMESTAMP], [DB_CREATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], _ORGANIZATION_HIST_ID, END_DATE_HIST, EFFECTIVE_DATE_HIST)
      select [ORGANIZATION_ID], [PRNT_ORGANIZATION_ID], [ADDRESS_ID], [REGION_CODE], [DISTRICT_CODE], [ORGANIZATION_TYPE_CODE], [ORG_IDENTIFIER_TYPE_CODE], [ORGANIZATION_IDENTIFIER], [ORGANIZATION_NAME], [ORGANIZATION_ALIAS], [WEBSITE], [IS_DISABLED], [CONCURRENCY_CONTROL_NUMBER], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [DB_CREATE_TIMESTAMP], [DB_CREATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], (next value for [dbo].[PIMS_ORGANIZATION_H_ID_SEQ]) as [_ORGANIZATION_HIST_ID], null as [END_DATE_HIST], @curr_date as [EFFECTIVE_DATE_HIST] from inserted;

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC pims_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger dbo.PIMS_LEASE_A_S_IUD_TR
PRINT N'Create trigger dbo.PIMS_LEASE_A_S_IUD_TR'
GO
CREATE TRIGGER [dbo].[PIMS_LEASE_A_S_IUD_TR] ON PIMS_LEASE FOR INSERT, UPDATE, DELETE AS
SET NOCOUNT ON
BEGIN TRY
DECLARE @curr_date datetime;
SET @curr_date = getutcdate();
  IF NOT EXISTS(SELECT * FROM inserted) AND NOT EXISTS(SELECT * FROM deleted)
    RETURN;

  -- historical
  IF EXISTS(SELECT * FROM deleted)
    update PIMS_LEASE_HIST set END_DATE_HIST = @curr_date where LEASE_ID in (select LEASE_ID from deleted) and END_DATE_HIST is null;

  IF EXISTS(SELECT * FROM inserted)
    insert into PIMS_LEASE_HIST ([LEASE_ID], [MOTI_NAME_ID], [LEASE_PAY_RVBL_TYPE_CODE], [LEASE_LICENSE_TYPE_CODE], [LEASE_CATEGORY_TYPE_CODE], [LEASE_PURPOSE_TYPE_CODE], [LEASE_PROGRAM_TYPE_CODE], [LEASE_INITIATOR_TYPE_CODE], [LEASE_RESPONSIBILITY_TYPE_CODE], [LEASE_PMT_FREQ_TYPE_CODE], [LEASE_PURPOSE_OTHER_DESC], [L_FILE_NO], [TFA_FILE_NO], [PS_FILE_NO], [LEASE_DESCRIPTION], [LEASE_NOTES], [ORIG_START_DATE], [ORIG_EXPIRY_DATE], [IS_ORIG_EXPIRY_REQUIRED], [INCLUDED_RENEWALS], [RENEWAL_COUNT], [RENEWAL_TERM_MONTHS], [LEASE_AMOUNT], [RESPONSIBILITY_EFFECTIVE_DATE], [INSPECTION_DATE], [INSPECTION_NOTES], [IS_SUBJECT_TO_RTA], [IS_COMM_BLDG], [IS_OTHER_IMPROVEMENT], [IS_EXPIRED], [HAS_PHYSICAL_FILE], [HAS_DIGITAL_FILE], [HAS_PHYSICIAL_LICENSE], [HAS_DIGITAL_LICENSE], [CONCURRENCY_CONTROL_NUMBER], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [DB_CREATE_TIMESTAMP], [DB_CREATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], _LEASE_HIST_ID, END_DATE_HIST, EFFECTIVE_DATE_HIST)
      select [LEASE_ID], [MOTI_NAME_ID], [LEASE_PAY_RVBL_TYPE_CODE], [LEASE_LICENSE_TYPE_CODE], [LEASE_CATEGORY_TYPE_CODE], [LEASE_PURPOSE_TYPE_CODE], [LEASE_PROGRAM_TYPE_CODE], [LEASE_INITIATOR_TYPE_CODE], [LEASE_RESPONSIBILITY_TYPE_CODE], [LEASE_PMT_FREQ_TYPE_CODE], [LEASE_PURPOSE_OTHER_DESC], [L_FILE_NO], [TFA_FILE_NO], [PS_FILE_NO], [LEASE_DESCRIPTION], [LEASE_NOTES], [ORIG_START_DATE], [ORIG_EXPIRY_DATE], [IS_ORIG_EXPIRY_REQUIRED], [INCLUDED_RENEWALS], [RENEWAL_COUNT], [RENEWAL_TERM_MONTHS], [LEASE_AMOUNT], [RESPONSIBILITY_EFFECTIVE_DATE], [INSPECTION_DATE], [INSPECTION_NOTES], [IS_SUBJECT_TO_RTA], [IS_COMM_BLDG], [IS_OTHER_IMPROVEMENT], [IS_EXPIRED], [HAS_PHYSICAL_FILE], [HAS_DIGITAL_FILE], [HAS_PHYSICIAL_LICENSE], [HAS_DIGITAL_LICENSE], [CONCURRENCY_CONTROL_NUMBER], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [DB_CREATE_TIMESTAMP], [DB_CREATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], (next value for [dbo].[PIMS_LEASE_H_ID_SEQ]) as [_LEASE_HIST_ID], null as [END_DATE_HIST], @curr_date as [EFFECTIVE_DATE_HIST] from inserted;

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC pims_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger dbo.PIMS_LEASE_I_S_U_TR
PRINT N'Create trigger dbo.PIMS_LEASE_I_S_U_TR'
GO
CREATE TRIGGER [dbo].[PIMS_LEASE_I_S_U_TR] ON PIMS_LEASE INSTEAD OF UPDATE AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM deleted)
    RETURN;
                                      
  -- validate concurrency control
  if exists (select 1 from inserted, deleted where inserted.CONCURRENCY_CONTROL_NUMBER != deleted.CONCURRENCY_CONTROL_NUMBER+1 AND inserted.LEASE_ID = deleted.LEASE_ID)
    raiserror('CONCURRENCY FAILURE.',16,1)


  -- update statement
  update PIMS_LEASE
    set "LEASE_ID" = inserted."LEASE_ID",
      "MOTI_NAME_ID" = inserted."MOTI_NAME_ID",
      "LEASE_PAY_RVBL_TYPE_CODE" = inserted."LEASE_PAY_RVBL_TYPE_CODE",
      "LEASE_LICENSE_TYPE_CODE" = inserted."LEASE_LICENSE_TYPE_CODE",
      "LEASE_CATEGORY_TYPE_CODE" = inserted."LEASE_CATEGORY_TYPE_CODE",
      "LEASE_PURPOSE_TYPE_CODE" = inserted."LEASE_PURPOSE_TYPE_CODE",
      "LEASE_PROGRAM_TYPE_CODE" = inserted."LEASE_PROGRAM_TYPE_CODE",
      "LEASE_INITIATOR_TYPE_CODE" = inserted."LEASE_INITIATOR_TYPE_CODE",
      "LEASE_RESPONSIBILITY_TYPE_CODE" = inserted."LEASE_RESPONSIBILITY_TYPE_CODE",
      "LEASE_PMT_FREQ_TYPE_CODE" = inserted."LEASE_PMT_FREQ_TYPE_CODE",
      "LEASE_PURPOSE_OTHER_DESC" = inserted."LEASE_PURPOSE_OTHER_DESC",
      "L_FILE_NO" = inserted."L_FILE_NO",
      "TFA_FILE_NO" = inserted."TFA_FILE_NO",
      "PS_FILE_NO" = inserted."PS_FILE_NO",
      "LEASE_DESCRIPTION" = inserted."LEASE_DESCRIPTION",
      "LEASE_NOTES" = inserted."LEASE_NOTES",
      "ORIG_START_DATE" = inserted."ORIG_START_DATE",
      "ORIG_EXPIRY_DATE" = inserted."ORIG_EXPIRY_DATE",
      "IS_ORIG_EXPIRY_REQUIRED" = inserted."IS_ORIG_EXPIRY_REQUIRED",
      "INCLUDED_RENEWALS" = inserted."INCLUDED_RENEWALS",  
      "RENEWAL_COUNT" = inserted."RENEWAL_COUNT",
      "RENEWAL_TERM_MONTHS" = inserted."RENEWAL_TERM_MONTHS",
      "LEASE_AMOUNT" = inserted."LEASE_AMOUNT",
      "RESPONSIBILITY_EFFECTIVE_DATE" = inserted."RESPONSIBILITY_EFFECTIVE_DATE",
      "INSPECTION_DATE" = inserted."INSPECTION_DATE",
      "INSPECTION_NOTES" = inserted."INSPECTION_NOTES",
      "IS_SUBJECT_TO_RTA" = inserted."IS_SUBJECT_TO_RTA",
      "IS_COMM_BLDG" = inserted."IS_COMM_BLDG",
      "IS_OTHER_IMPROVEMENT" = inserted."IS_OTHER_IMPROVEMENT",
      "IS_EXPIRED" = inserted."IS_EXPIRED",
      "HAS_PHYSICAL_FILE" = inserted."HAS_PHYSICAL_FILE",
      "HAS_DIGITAL_FILE" = inserted."HAS_DIGITAL_FILE",
      "HAS_PHYSICIAL_LICENSE" = inserted."HAS_PHYSICIAL_LICENSE",
      "HAS_DIGITAL_LICENSE" = inserted."HAS_DIGITAL_LICENSE",
      "CONCURRENCY_CONTROL_NUMBER" = inserted."CONCURRENCY_CONTROL_NUMBER",
      "APP_LAST_UPDATE_TIMESTAMP" = inserted."APP_LAST_UPDATE_TIMESTAMP",
      "APP_LAST_UPDATE_USERID" = inserted."APP_LAST_UPDATE_USERID",
      "APP_LAST_UPDATE_USER_GUID" = inserted."APP_LAST_UPDATE_USER_GUID",
      "APP_LAST_UPDATE_USER_DIRECTORY" = inserted."APP_LAST_UPDATE_USER_DIRECTORY"
    , DB_LAST_UPDATE_TIMESTAMP = getutcdate()
    , DB_LAST_UPDATE_USERID = user_name()
    from PIMS_LEASE
    inner join inserted
    on (PIMS_LEASE.LEASE_ID = inserted.LEASE_ID);

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC pims_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger dbo.PIMS_TENANT_I_S_U_TR
PRINT N'Create trigger dbo.PIMS_TENANT_I_S_U_TR'
GO
CREATE TRIGGER [dbo].[PIMS_TENANT_I_S_U_TR] ON PIMS_LEASE_TENANT INSTEAD OF UPDATE AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM deleted)
    RETURN;

  -- validate concurrency control
  if exists (select 1 from inserted, deleted where inserted.CONCURRENCY_CONTROL_NUMBER != deleted.CONCURRENCY_CONTROL_NUMBER+1 AND inserted.LEASE_TENANT_ID = deleted.LEASE_TENANT_ID)
    raiserror('CONCURRENCY FAILURE.',16,1)


  -- update statement
  update PIMS_LEASE_TENANT
    set "LEASE_TENANT_ID" = inserted."LEASE_TENANT_ID",
      "LEASE_ID" = inserted."LEASE_ID",
      "PERSON_ID" = inserted."PERSON_ID",
      "ORGANIZATION_ID" = inserted."ORGANIZATION_ID",
      "LESSOR_TYPE_CODE" = inserted."LESSOR_TYPE_CODE",
      "NOTE" = inserted."NOTE",
      "CONCURRENCY_CONTROL_NUMBER" = inserted."CONCURRENCY_CONTROL_NUMBER",
      "APP_LAST_UPDATE_TIMESTAMP" = inserted."APP_LAST_UPDATE_TIMESTAMP",
      "APP_LAST_UPDATE_USERID" = inserted."APP_LAST_UPDATE_USERID",
      "APP_LAST_UPDATE_USER_GUID" = inserted."APP_LAST_UPDATE_USER_GUID",
      "APP_LAST_UPDATE_USER_DIRECTORY" = inserted."APP_LAST_UPDATE_USER_DIRECTORY"
    , DB_LAST_UPDATE_TIMESTAMP = getutcdate()
    , DB_LAST_UPDATE_USERID = user_name()
    from PIMS_LEASE_TENANT
    inner join inserted
    on (PIMS_LEASE_TENANT.LEASE_TENANT_ID = inserted.LEASE_TENANT_ID);

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC pims_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger dbo.PIMS_LSPYMT_I_S_U_TR
PRINT N'Create trigger dbo.PIMS_LSPYMT_I_S_U_TR'
GO
CREATE TRIGGER [dbo].[PIMS_LSPYMT_I_S_U_TR] ON PIMS_LEASE_PAYMENT INSTEAD OF UPDATE AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM deleted)
    RETURN;

  -- validate concurrency control
  if exists (select 1 from inserted, deleted where inserted.CONCURRENCY_CONTROL_NUMBER != deleted.CONCURRENCY_CONTROL_NUMBER+1 AND inserted.LEASE_PAYMENT_ID = deleted.LEASE_PAYMENT_ID)
    raiserror('CONCURRENCY FAILURE.',16,1)


  -- update statement
  update PIMS_LEASE_PAYMENT
    set "LEASE_PAYMENT_ID" = inserted."LEASE_PAYMENT_ID",
      "LEASE_TERM_ID" = inserted."LEASE_TERM_ID",
      "LEASE_PAYMENT_PERIOD_ID" = inserted."LEASE_PAYMENT_PERIOD_ID",
      "LEASE_PAYMENT_METHOD_TYPE_CODE" = inserted."LEASE_PAYMENT_METHOD_TYPE_CODE",
      "PAYMENT_RECEIVED_DATE" = inserted."PAYMENT_RECEIVED_DATE",
      "PAYMENT_AMOUNT_PRE_TAX" = inserted."PAYMENT_AMOUNT_PRE_TAX",
      "PAYMENT_AMOUNT_PST" = inserted."PAYMENT_AMOUNT_PST",
      "PAYMENT_AMOUNT_GST" = inserted."PAYMENT_AMOUNT_GST",
      "PAYMENT_AMOUNT_TOTAL" = inserted."PAYMENT_AMOUNT_TOTAL",
      "NOTE" = inserted."NOTE",
      "CONCURRENCY_CONTROL_NUMBER" = inserted."CONCURRENCY_CONTROL_NUMBER",
      "APP_LAST_UPDATE_TIMESTAMP" = inserted."APP_LAST_UPDATE_TIMESTAMP",
      "APP_LAST_UPDATE_USERID" = inserted."APP_LAST_UPDATE_USERID",
      "APP_LAST_UPDATE_USER_GUID" = inserted."APP_LAST_UPDATE_USER_GUID",
      "APP_LAST_UPDATE_USER_DIRECTORY" = inserted."APP_LAST_UPDATE_USER_DIRECTORY"
    , DB_LAST_UPDATE_TIMESTAMP = getutcdate()
    , DB_LAST_UPDATE_USERID = user_name()
    from PIMS_LEASE_PAYMENT
    inner join inserted
    on (PIMS_LEASE_PAYMENT.LEASE_PAYMENT_ID = inserted.LEASE_PAYMENT_ID);

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC pims_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create foreign key constraint PIM_LINITT_PIM_LEASE_FK
PRINT N'Create foreign key constraint PIM_LINITT_PIM_LEASE_FK'
GO
ALTER TABLE [dbo].[PIMS_LEASE]
	ADD FOREIGN KEY([LEASE_INITIATOR_TYPE_CODE])
	REFERENCES [dbo].[PIMS_LEASE_INITIATOR_TYPE]([LEASE_INITIATOR_TYPE_CODE])
	ON DELETE NO ACTION 
	ON UPDATE NO ACTION 
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create foreign key constraint PIM_LRESPT_PIM_LEASE_FK
PRINT N'Create foreign key constraint PIM_LRESPT_PIM_LEASE_FK'
GO
ALTER TABLE [dbo].[PIMS_LEASE]
	ADD FOREIGN KEY([LEASE_RESPONSIBILITY_TYPE_CODE])
	REFERENCES [dbo].[PIMS_LEASE_RESPONSIBILITY_TYPE]([LEASE_RESPONSIBILITY_TYPE_CODE])
	ON DELETE NO ACTION 
	ON UPDATE NO ACTION 
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create foreign key constraint PIM_LEASE_PIM_LSTERM_FK
PRINT N'Create foreign key constraint PIM_LEASE_PIM_LSTERM_FK'
GO
ALTER TABLE [dbo].[PIMS_LEASE_TERM]
	ADD FOREIGN KEY([LEASE_ID])
	REFERENCES [dbo].[PIMS_LEASE]([LEASE_ID])
	ON DELETE NO ACTION 
	ON UPDATE NO ACTION 
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create foreign key constraint PIM_LTRMST_PIM_LSTERM_FK
PRINT N'Create foreign key constraint PIM_LTRMST_PIM_LSTERM_FK'
GO
ALTER TABLE [dbo].[PIMS_LEASE_TERM]
	ADD FOREIGN KEY([LEASE_TERM_STATUS_TYPE_CODE])
	REFERENCES [dbo].[PIMS_LEASE_TERM_STATUS_TYPE]([LEASE_TERM_STATUS_TYPE_CODE])
	ON DELETE NO ACTION 
	ON UPDATE NO ACTION 
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create foreign key constraint PIM_LPSTST_PIM_LPFCST_FK
PRINT N'Create foreign key constraint PIM_LPSTST_PIM_LPFCST_FK'
GO
ALTER TABLE [dbo].[PIMS_LEASE_PAYMENT_FORECAST]
	ADD FOREIGN KEY([LEASE_PAYMENT_STATUS_TYPE_CODE])
	REFERENCES [dbo].[PIMS_LEASE_PAYMENT_STATUS_TYPE]([LEASE_PAYMENT_STATUS_TYPE_CODE])
	ON DELETE NO ACTION 
	ON UPDATE NO ACTION 
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create foreign key constraint PIM_LPYPER_PIM_LPFCST_FK
PRINT N'Create foreign key constraint PIM_LPYPER_PIM_LPFCST_FK'
GO
ALTER TABLE [dbo].[PIMS_LEASE_PAYMENT_FORECAST]
	ADD FOREIGN KEY([LEASE_PAYMENT_PERIOD_ID])
	REFERENCES [dbo].[PIMS_LEASE_PAYMENT_PERIOD]([LEASE_PAYMENT_PERIOD_ID])
	ON DELETE NO ACTION 
	ON UPDATE NO ACTION 
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create foreign key constraint PIM_LSTERM_PIM_LPFCST_FK
PRINT N'Create foreign key constraint PIM_LSTERM_PIM_LPFCST_FK'
GO
ALTER TABLE [dbo].[PIMS_LEASE_PAYMENT_FORECAST]
	ADD FOREIGN KEY([LEASE_TERM_ID])
	REFERENCES [dbo].[PIMS_LEASE_TERM]([LEASE_TERM_ID])
	ON DELETE NO ACTION 
	ON UPDATE NO ACTION 
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create foreign key constraint PIM_LSTERM_PIM_LSPYMT_FK
PRINT N'Create foreign key constraint PIM_LSTERM_PIM_LSPYMT_FK'
GO
ALTER TABLE [dbo].[PIMS_LEASE_PAYMENT]
	ADD FOREIGN KEY([LEASE_TERM_ID])
	REFERENCES [dbo].[PIMS_LEASE_TERM]([LEASE_TERM_ID])
	ON DELETE NO ACTION 
	ON UPDATE NO ACTION 
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create foreign key constraint PIM_LSPMMT_PIM_LSPYMT_FK
PRINT N'Create foreign key constraint PIM_LSPMMT_PIM_LSPYMT_FK'
GO
ALTER TABLE [dbo].[PIMS_LEASE_PAYMENT]
	ADD FOREIGN KEY([LEASE_PAYMENT_METHOD_TYPE_CODE])
	REFERENCES [dbo].[PIMS_LEASE_PAYMENT_METHOD_TYPE]([LEASE_PAYMENT_METHOD_TYPE_CODE])
	ON DELETE NO ACTION 
	ON UPDATE NO ACTION 
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create foreign key constraint PIM_LPYPER_PIM_LSPYMT_FK
PRINT N'Create foreign key constraint PIM_LPYPER_PIM_LSPYMT_FK'
GO
ALTER TABLE [dbo].[PIMS_LEASE_PAYMENT]
	ADD FOREIGN KEY([LEASE_PAYMENT_PERIOD_ID])
	REFERENCES [dbo].[PIMS_LEASE_PAYMENT_PERIOD]([LEASE_PAYMENT_PERIOD_ID])
	ON DELETE NO ACTION 
	ON UPDATE NO ACTION 
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger dbo.PIMS_PIMPRV_A_S_IUD_TR
PRINT N'Create trigger dbo.PIMS_PIMPRV_A_S_IUD_TR'
GO
CREATE TRIGGER [dbo].[PIMS_PIMPRV_A_S_IUD_TR] ON PIMS_PROPERTY_IMPROVEMENT FOR INSERT, UPDATE, DELETE AS
SET NOCOUNT ON
BEGIN TRY
DECLARE @curr_date datetime;
SET @curr_date = getutcdate();
  IF NOT EXISTS(SELECT * FROM inserted) AND NOT EXISTS(SELECT * FROM deleted)
    RETURN;

  -- historical
  IF EXISTS(SELECT * FROM deleted)
    update PIMS_PROPERTY_IMPROVEMENT_HIST set END_DATE_HIST = @curr_date where PROPERTY_IMPROVEMENT_ID in (select PROPERTY_IMPROVEMENT_ID from deleted) and END_DATE_HIST is null;

  IF EXISTS(SELECT * FROM inserted)
    insert into PIMS_PROPERTY_IMPROVEMENT_HIST ([PROPERTY_IMPROVEMENT_ID], [PROPERTY_LEASE_ID], [PROPERTY_IMPROVEMENT_TYPE_CODE], [IMPROVEMENT_DESCRIPTION], [STRUCTURE_SIZE], [UNIT], [CONCURRENCY_CONTROL_NUMBER], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [DB_CREATE_TIMESTAMP], [DB_CREATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], _PROPERTY_IMPROVEMENT_HIST_ID, END_DATE_HIST, EFFECTIVE_DATE_HIST)
      select [PROPERTY_IMPROVEMENT_ID], [PROPERTY_LEASE_ID], [PROPERTY_IMPROVEMENT_TYPE_CODE], [IMPROVEMENT_DESCRIPTION], [STRUCTURE_SIZE], [UNIT], [CONCURRENCY_CONTROL_NUMBER], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [DB_CREATE_TIMESTAMP], [DB_CREATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], (next value for [dbo].[PIMS_PROPERTY_IMPROVEMENT_H_ID_SEQ]) as [_PROPERTY_IMPROVEMENT_HIST_ID], null as [END_DATE_HIST], @curr_date as [EFFECTIVE_DATE_HIST] from inserted;

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC pims_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger dbo.PIMS_LEASE_I_S_I_TR
PRINT N'Create trigger dbo.PIMS_LEASE_I_S_I_TR'
GO
CREATE TRIGGER [dbo].[PIMS_LEASE_I_S_I_TR] ON PIMS_LEASE INSTEAD OF INSERT AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM inserted)
    RETURN;


  insert into PIMS_LEASE ("LEASE_ID",
      "MOTI_NAME_ID",
      "LEASE_PAY_RVBL_TYPE_CODE",
      "LEASE_LICENSE_TYPE_CODE",
      "LEASE_CATEGORY_TYPE_CODE",
      "LEASE_PURPOSE_TYPE_CODE",
      "LEASE_PROGRAM_TYPE_CODE",
      "LEASE_INITIATOR_TYPE_CODE",
      "LEASE_RESPONSIBILITY_TYPE_CODE",
      "LEASE_PMT_FREQ_TYPE_CODE",
      "LEASE_PURPOSE_OTHER_DESC",
      "L_FILE_NO",
      "TFA_FILE_NO",
      "PS_FILE_NO",
      "LEASE_DESCRIPTION",
      "LEASE_NOTES",
      "ORIG_START_DATE",
      "ORIG_EXPIRY_DATE",
      "IS_ORIG_EXPIRY_REQUIRED",
      "INCLUDED_RENEWALS",
      "RENEWAL_COUNT",             
      "RENEWAL_TERM_MONTHS",      
      "LEASE_AMOUNT",
      "RESPONSIBILITY_EFFECTIVE_DATE",
      "INSPECTION_DATE",
      "INSPECTION_NOTES",
      "IS_SUBJECT_TO_RTA",
      "IS_COMM_BLDG",
      "IS_OTHER_IMPROVEMENT",
      "IS_EXPIRED",
      "HAS_PHYSICAL_FILE",
      "HAS_DIGITAL_FILE",
      "HAS_PHYSICIAL_LICENSE",
      "HAS_DIGITAL_LICENSE",
      "CONCURRENCY_CONTROL_NUMBER",
      "APP_CREATE_TIMESTAMP",
      "APP_CREATE_USERID",
      "APP_CREATE_USER_GUID",
      "APP_CREATE_USER_DIRECTORY",
      "APP_LAST_UPDATE_TIMESTAMP",
      "APP_LAST_UPDATE_USERID",
      "APP_LAST_UPDATE_USER_GUID",
      "APP_LAST_UPDATE_USER_DIRECTORY")
    select "LEASE_ID",
      "MOTI_NAME_ID",
      "LEASE_PAY_RVBL_TYPE_CODE",
      "LEASE_LICENSE_TYPE_CODE",
      "LEASE_CATEGORY_TYPE_CODE",
      "LEASE_PURPOSE_TYPE_CODE",
      "LEASE_PROGRAM_TYPE_CODE",
      "LEASE_INITIATOR_TYPE_CODE",
      "LEASE_RESPONSIBILITY_TYPE_CODE",
      "LEASE_PMT_FREQ_TYPE_CODE",
      "LEASE_PURPOSE_OTHER_DESC",
      "L_FILE_NO",
      "TFA_FILE_NO",
      "PS_FILE_NO",
      "LEASE_DESCRIPTION",
      "LEASE_NOTES",
      "ORIG_START_DATE",
      "ORIG_EXPIRY_DATE",
      "IS_ORIG_EXPIRY_REQUIRED",
      "INCLUDED_RENEWALS",
      "RENEWAL_COUNT",   
      "RENEWAL_TERM_MONTHS",      
      "LEASE_AMOUNT",
      "RESPONSIBILITY_EFFECTIVE_DATE",
      "INSPECTION_DATE",
      "INSPECTION_NOTES",
      "IS_SUBJECT_TO_RTA",
      "IS_COMM_BLDG",
      "IS_OTHER_IMPROVEMENT",
      "IS_EXPIRED",
      "HAS_PHYSICAL_FILE",
      "HAS_DIGITAL_FILE",
      "HAS_PHYSICIAL_LICENSE",
      "HAS_DIGITAL_LICENSE",
      "CONCURRENCY_CONTROL_NUMBER",
      "APP_CREATE_TIMESTAMP",
      "APP_CREATE_USERID",
      "APP_CREATE_USER_GUID",
      "APP_CREATE_USER_DIRECTORY",
      "APP_LAST_UPDATE_TIMESTAMP",
      "APP_LAST_UPDATE_USERID",
      "APP_LAST_UPDATE_USER_GUID",
      "APP_LAST_UPDATE_USER_DIRECTORY"
    from inserted;

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC pims_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger dbo.PIMS_LPSTST_I_S_I_TR
PRINT N'Create trigger dbo.PIMS_LPSTST_I_S_I_TR'
GO
CREATE TRIGGER [dbo].[PIMS_LPSTST_I_S_I_TR] ON PIMS_LEASE_PAYMENT_STATUS_TYPE INSTEAD OF INSERT AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM inserted)
    RETURN;


  insert into PIMS_LEASE_PAYMENT_STATUS_TYPE ("LEASE_PAYMENT_STATUS_TYPE_CODE",
      "DESCRIPTION",
      "IS_DISABLED",
      "DISPLAY_ORDER",
      "CONCURRENCY_CONTROL_NUMBER")
    select "LEASE_PAYMENT_STATUS_TYPE_CODE",
      "DESCRIPTION",
      "IS_DISABLED",
      "DISPLAY_ORDER",
      "CONCURRENCY_CONTROL_NUMBER"
    from inserted;

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC pims_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger dbo.PIMS_LPYPER_I_S_I_TR
PRINT N'Create trigger dbo.PIMS_LPYPER_I_S_I_TR'
GO
CREATE TRIGGER [dbo].[PIMS_LPYPER_I_S_I_TR] ON PIMS_LEASE_PAYMENT_PERIOD INSTEAD OF INSERT AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM inserted)
    RETURN;


  insert into PIMS_LEASE_PAYMENT_PERIOD ("LEASE_PAYMENT_PERIOD_ID",
      "PERIOD_START_DATE",
      "IS_PERIOD_CLOSED",
      "CONCURRENCY_CONTROL_NUMBER",
      "APP_CREATE_TIMESTAMP",
      "APP_CREATE_USERID",
      "APP_CREATE_USER_GUID",
      "APP_CREATE_USER_DIRECTORY",
      "APP_LAST_UPDATE_TIMESTAMP",
      "APP_LAST_UPDATE_USERID",
      "APP_LAST_UPDATE_USER_GUID",
      "APP_LAST_UPDATE_USER_DIRECTORY")
    select "LEASE_PAYMENT_PERIOD_ID",
      "PERIOD_START_DATE",
      "IS_PERIOD_CLOSED",
      "CONCURRENCY_CONTROL_NUMBER",
      "APP_CREATE_TIMESTAMP",
      "APP_CREATE_USERID",
      "APP_CREATE_USER_GUID",
      "APP_CREATE_USER_DIRECTORY",
      "APP_LAST_UPDATE_TIMESTAMP",
      "APP_LAST_UPDATE_USERID",
      "APP_LAST_UPDATE_USER_GUID",
      "APP_LAST_UPDATE_USER_DIRECTORY"
    from inserted;

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC pims_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Drop table dbo.PIMS_PROPERTY_IMPROVEMENT_UOM_TYPE
PRINT N'Drop table dbo.PIMS_PROPERTY_IMPROVEMENT_UOM_TYPE'
GO
DROP TABLE [dbo].[PIMS_PROPERTY_IMPROVEMENT_UOM_TYPE]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

COMMIT TRANSACTION
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO
DECLARE @Success AS BIT
SET @Success = 1
SET NOEXEC OFF
IF (@Success = 1) PRINT 'The database update succeeded'
ELSE BEGIN
   IF @@TRANCOUNT > 0 ROLLBACK TRANSACTION
   PRINT 'The database update failed'
END
GO
